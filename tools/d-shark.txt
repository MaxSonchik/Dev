Project Path: d-shark

Source Tree:

```txt
d-shark
├── Cargo.lock
├── Cargo.toml
└── src
    ├── analysis
    │   ├── mod.rs
    │   └── process.rs
    ├── capture
    │   ├── engine.rs
    │   ├── mod.rs
    │   └── model.rs
    ├── firewall.rs
    ├── main.rs
    └── ui
        ├── app.rs
        └── mod.rs

```

`Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "allocator-api2"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "683d7910e743518b0e34f1186f92494becacb047c7b6bf616c96772180fef923"

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "anstream"
version = "0.6.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "43d5b281e737544384e969a5ccad3f1cdd24b48086a0fc1b2a5262a26b8f4f4a"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5192cca8006f1fd4f7237516f40fa183bb07f8fbdfedaa0036de5ea9b0b45e78"

[[package]]
name = "anstyle-parse"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4e7644824f0aa2c7b9384579234ef10eb7efb6a0deb83f9630a49594dd9c15c2"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40c48f72fd53cd289104fc64099abca73db4166ad86ea0b4341abe65af83dadc"
dependencies = [
 "windows-sys 0.61.2",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "291e6a250ff86cd4a820112fb8898808a366d8f9f58ce16d1f538353ad55747d"
dependencies = [
 "anstyle",
 "once_cell_polyfill",
 "windows-sys 0.61.2",
]

[[package]]
name = "anyhow"
version = "1.0.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a23eb6b1614318a8071c9b2521f36b424b2c83db5eb3a0fead4a6c0809af6e61"

[[package]]
name = "autocfg"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "812e12b5285cc515a9c72a5c1d3b6d46a19dac5acfef5265968c166106e31dd3"

[[package]]
name = "bumpalo"
version = "3.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bytes"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b35204fbdc0b3f4446b89fc1ac2cf84a8a68971995d0bf2e925ec7cd960f9cb3"

[[package]]
name = "cassowary"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df8670b8c7b9dae1793364eafadf7239c40d669904660c5960d74cfd80b46a53"

[[package]]
name = "castaway"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dec551ab6e7578819132c713a93c022a05d60159dc86e7a7050223577484c55a"
dependencies = [
 "rustversion",
]

[[package]]
name = "cc"
version = "1.2.49"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "90583009037521a116abf44494efecd645ba48b6622457080f080b85544e2215"
dependencies = [
 "find-msvc-tools",
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9330f8b2ff13f34540b44e946ef35111825727b38d33286ef986142615121801"

[[package]]
name = "chrono"
version = "0.4.42"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
dependencies = [
 "iana-time-zone",
 "js-sys",
 "num-traits",
 "wasm-bindgen",
 "windows-link",
]

[[package]]
name = "clap"
version = "4.5.53"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c9e340e012a1bf4935f5282ed1436d1489548e8f72308207ea5df0e23d2d03f8"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap_builder"
version = "4.5.53"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d76b5d13eaa18c901fd2f7fca939fefe3a0727a953561fefdf3b2922b8569d00"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_derive"
version = "4.5.49"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2a0b5487afeab2deb2ff4e03a807ad1a03ac532ff5a2cee5d86884440c7f7671"
dependencies = [
 "heck",
 "proc-macro2",
 "quote 1.0.42",
 "syn 2.0.111",
]

[[package]]
name = "clap_lex"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1d728cc89cf3aee9ff92b05e62b19ee65a02b5702cff7d5a377e32c6ae29d8d"

[[package]]
name = "colorchoice"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b05b61dc5112cbb17e4b6cd61790d9845d13888356391624cbe7e41efeac1e75"

[[package]]
name = "compact_str"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f86b9c4c00838774a6d902ef931eff7470720c51d90c2e32cfe15dc304737b3f"
dependencies = [
 "castaway",
 "cfg-if",
 "itoa",
 "ryu",
 "static_assertions",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "crossterm"
version = "0.27.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f476fe445d41c9e991fd07515a6f463074b782242ccf4a5b7b1d1012e70824df"
dependencies = [
 "bitflags 2.10.0",
 "crossterm_winapi",
 "libc",
 "mio 0.8.11",
 "parking_lot",
 "signal-hook",
 "signal-hook-mio",
 "winapi",
]

[[package]]
name = "crossterm_winapi"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "acdd7c62a3665c7f6830a51635d9ac9b23ed385797f70a83bb8bafe9c572ab2b"
dependencies = [
 "winapi",
]

[[package]]
name = "d-shark"
version = "0.2.0"
dependencies = [
 "anyhow",
 "chrono",
 "clap",
 "crossterm",
 "glob",
 "libc",
 "log",
 "netlink-packet-core 0.4.2",
 "netlink-packet-sock-diag",
 "netlink-sys",
 "pcap-file",
 "pretty-hex",
 "ratatui",
 "serde",
 "serde_json",
 "tokio",
 "tokio-util",
 "tui-logger",
 "users",
]

[[package]]
name = "derive-into-owned"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "576fce04d31d592013a5887ba8d9c3830adff329e5096d7e1eb5e8e61262ca62"
dependencies = [
 "quote 0.3.15",
 "syn 0.11.11",
]

[[package]]
name = "either"
version = "1.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "find-msvc-tools"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3a3076410a55c90011c298b04d0cfa770b00fa04e1e3c97d3f6c9de105a03844"

[[package]]
name = "foldhash"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d9c4f5dac5e15c24eb999c26181a6ca40b39fe946cbe4c263c7209467bc83af2"

[[package]]
name = "futures-core"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"

[[package]]
name = "futures-sink"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e575fab7d1e0dcb8d0c7bcf9a63ee213816ab51902e6d244a95819acacf1d4f7"

[[package]]
name = "fxhash"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c31b6d751ae2c7f11320402d34e41349dd1016f8d5d45e48c4312bc8625af50c"
dependencies = [
 "byteorder",
]

[[package]]
name = "glob"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0cc23270f6e1808e30a928bdc84dea0b9b4136a8bc82338574f23baf47bbd280"

[[package]]
name = "hashbrown"
version = "0.15.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9229cfe53dfd69f0609a49f65461bd93001ea1ef889cd5529dd176593f5338a1"
dependencies = [
 "allocator-api2",
 "equivalent",
 "foldhash",
]

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "iana-time-zone"
version = "0.1.64"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
dependencies = [
 "android_system_properties",
 "core-foundation-sys",
 "iana-time-zone-haiku",
 "js-sys",
 "log",
 "wasm-bindgen",
 "windows-core",
]

[[package]]
name = "iana-time-zone-haiku"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
dependencies = [
 "cc",
]

[[package]]
name = "is_terminal_polyfill"
version = "1.70.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a6cb138bb79a146c1bd460005623e142ef0181e3d0219cb493e02f7d08a35695"

[[package]]
name = "itertools"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba291022dbbd398a455acf126c1e341954079855bc60dfdda641363bd6922569"
dependencies = [
 "either",
]

[[package]]
name = "itertools"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "413ee7dfc52ee1a4949ceeb7dbc8a33f2d6c088194d9f922fb8318faf1f01186"
dependencies = [
 "either",
]

[[package]]
name = "itoa"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c"

[[package]]
name = "js-sys"
version = "0.3.83"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "464a3709c7f55f1f721e5389aa6ea4e3bc6aba669353300af094b29ffbdde1d8"
dependencies = [
 "once_cell",
 "wasm-bindgen",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "libc"
version = "0.2.178"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37c93d8daa9d8a012fd8ab92f088405fb202ea0b6ab73ee2482ae66af4f42091"

[[package]]
name = "lock_api"
version = "0.4.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "224399e74b87b5f3557511d98dff8b14089b3dadafcab6bb93eab67d3aace965"
dependencies = [
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e5032e24019045c762d3c0f28f5b6b8bbf38563a65908389bf7978758920897"

[[package]]
name = "lru"
version = "0.12.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "234cf4f4a04dc1f57e24b96cc0cd600cf2af460d4161ac5ecdd0af8e1f3b2a38"
dependencies = [
 "hashbrown",
]

[[package]]
name = "memchr"
version = "2.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f52b00d39961fc5b2736ea853c9cc86238e165017a493d1d5c8eac6bdc4cc273"

[[package]]
name = "mio"
version = "0.8.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4a650543ca06a924e8b371db273b2756685faae30f8487da1b56505a8f78b0c"
dependencies = [
 "libc",
 "log",
 "wasi",
 "windows-sys 0.48.0",
]

[[package]]
name = "mio"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a69bcab0ad47271a0234d9422b131806bf3968021e5dc9328caf2d4cd58557fc"
dependencies = [
 "libc",
 "wasi",
 "windows-sys 0.61.2",
]

[[package]]
name = "netlink-packet-core"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "345b8ab5bd4e71a2986663e88c56856699d060e78e152e6e9d7966fcd5491297"
dependencies = [
 "anyhow",
 "byteorder",
 "libc",
 "netlink-packet-utils",
]

[[package]]
name = "netlink-packet-core"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72724faf704479d67b388da142b186f916188505e7e0b26719019c525882eda4"
dependencies = [
 "anyhow",
 "byteorder",
 "netlink-packet-utils",
]

[[package]]
name = "netlink-packet-sock-diag"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a495cb1de50560a7cd12fdcf023db70eec00e340df81be31cedbbfd4aadd6b76"
dependencies = [
 "anyhow",
 "bitflags 1.3.2",
 "byteorder",
 "libc",
 "netlink-packet-core 0.7.0",
 "netlink-packet-utils",
 "smallvec",
]

[[package]]
name = "netlink-packet-utils"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ede8a08c71ad5a95cdd0e4e52facd37190977039a4704eb82a283f713747d34"
dependencies = [
 "anyhow",
 "byteorder",
 "paste",
 "thiserror",
]

[[package]]
name = "netlink-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "16c903aa70590cb93691bf97a767c8d1d6122d2cc9070433deb3bbf36ce8bd23"
dependencies = [
 "bytes",
 "libc",
 "log",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
]

[[package]]
name = "numtoa"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8f8bdf33df195859076e54ab11ee78a1b208382d3a26ec40d142ffc1ecc49ef"

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "once_cell_polyfill"
version = "1.70.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "384b8ab6d37215f3c5301a95a4accb5d64aa607f1fcb26a11b5303878451b4fe"

[[package]]
name = "parking_lot"
version = "0.12.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93857453250e3077bd71ff98b6a65ea6621a19bb0f559a85248955ac12c45a1a"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2621685985a2ebf1c516881c026032ac7deafcda1a2c9b7850dc81e3dfcb64c1"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall 0.5.18",
 "smallvec",
 "windows-link",
]

[[package]]
name = "paste"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57c0d7b74b563b49d38dae00a0c37d4d6de9b432382b2892f0574ddcae73fd0a"

[[package]]
name = "pcap-file"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6ad13fed1a83120159aea81b265074f21d753d157dd16b10cc3790ecba40a341"
dependencies = [
 "byteorder",
 "derive-into-owned",
 "thiserror",
]

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "pretty-hex"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbc83ee4a840062f368f9096d80077a9841ec117e17e7f700df81958f1451254"

[[package]]
name = "proc-macro2"
version = "1.0.103"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5ee95bc4ef87b8d5ba32e8b7714ccc834865276eab0aed5c9958d00ec45f49e8"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "0.3.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a"

[[package]]
name = "quote"
version = "1.0.42"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a338cc41d27e6cc6dce6cefc13a0729dfbb81c262b1f519331575dd80ef3067f"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "ratatui"
version = "0.26.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f44c9e68fd46eda15c646fbb85e1040b657a58cdc8c98db1d97a55930d991eef"
dependencies = [
 "bitflags 2.10.0",
 "cassowary",
 "compact_str",
 "crossterm",
 "itertools 0.12.1",
 "lru",
 "paste",
 "stability",
 "strum",
 "unicode-segmentation",
 "unicode-truncate",
 "unicode-width",
]

[[package]]
name = "redox_syscall"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fb5a58c1855b4b6819d59012155603f0b22ad30cad752600aadfcb695265519a"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "redox_syscall"
version = "0.5.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed2bf2547551a7053d6fdfafda3f938979645c44812fbfcda098faae3f1a362d"
dependencies = [
 "bitflags 2.10.0",
]

[[package]]
name = "redox_termios"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "20145670ba436b55d91fc92d25e71160fbfbdd57831631c8d7d36377a476f1cb"

[[package]]
name = "rustversion"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"

[[package]]
name = "ryu"
version = "1.0.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f"

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "serde"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a8e94ea7f378bd32cbbd37198a4a91436180c5bb472411e48b5ec2e2124ae9e"
dependencies = [
 "serde_core",
 "serde_derive",
]

[[package]]
name = "serde_core"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41d385c7d4ca58e59fc732af25c3983b67ac852c1a25000afe1175de458b67ad"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d540f220d3187173da220f885ab66608367b6574e925011a9353e4badda91d79"
dependencies = [
 "proc-macro2",
 "quote 1.0.42",
 "syn 2.0.111",
]

[[package]]
name = "serde_json"
version = "1.0.145"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "402a6f66d8c709116cf22f558eab210f5a50187f702eb4d7e5ef38d9a7f1c79c"
dependencies = [
 "itoa",
 "memchr",
 "ryu",
 "serde",
 "serde_core",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signal-hook"
version = "0.3.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d881a16cf4426aa584979d30bd82cb33429027e42122b169753d6ef1085ed6e2"
dependencies = [
 "libc",
 "signal-hook-registry",
]

[[package]]
name = "signal-hook-mio"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b75a19a7a740b25bc7944bdee6172368f988763b744e3d4dfe753f6b4ece40cc"
dependencies = [
 "libc",
 "mio 0.8.11",
 "signal-hook",
]

[[package]]
name = "signal-hook-registry"
version = "1.4.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7664a098b8e616bdfcc2dc0e9ac44eb231eedf41db4e9fe95d8d32ec728dedad"
dependencies = [
 "libc",
]

[[package]]
name = "smallvec"
version = "1.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"

[[package]]
name = "socket2"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17129e116933cf371d018bb80ae557e889637989d8638274fb25622827b03881"
dependencies = [
 "libc",
 "windows-sys 0.60.2",
]

[[package]]
name = "stability"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d904e7009df136af5297832a3ace3370cd14ff1546a232f4f185036c2736fcac"
dependencies = [
 "quote 1.0.42",
 "syn 2.0.111",
]

[[package]]
name = "static_assertions"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "strum"
version = "0.26.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8fec0f0aef304996cf250b31b5a10dee7980c85da9d759361292b8bca5a18f06"
dependencies = [
 "strum_macros",
]

[[package]]
name = "strum_macros"
version = "0.26.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c6bee85a5a24955dc440386795aa378cd9cf82acd5f764469152d2270e581be"
dependencies = [
 "heck",
 "proc-macro2",
 "quote 1.0.42",
 "rustversion",
 "syn 2.0.111",
]

[[package]]
name = "syn"
version = "0.11.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3b891b9015c88c576343b9b3e41c2c11a51c219ef067b264bd9c8aa9b441dad"
dependencies = [
 "quote 0.3.15",
 "synom",
 "unicode-xid",
]

[[package]]
name = "syn"
version = "2.0.111"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "390cc9a294ab71bdb1aa2e99d13be9c753cd2d7bd6560c77118597410c4d2e87"
dependencies = [
 "proc-macro2",
 "quote 1.0.42",
 "unicode-ident",
]

[[package]]
name = "synom"
version = "0.11.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a393066ed9010ebaed60b9eafa373d4b1baac186dd7e008555b0f702b51945b6"
dependencies = [
 "unicode-xid",
]

[[package]]
name = "termion"
version = "1.5.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "077185e2eac69c3f8379a4298e1e07cd36beb962290d4a51199acf0fdc10607e"
dependencies = [
 "libc",
 "numtoa",
 "redox_syscall 0.2.16",
 "redox_termios",
]

[[package]]
name = "thiserror"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
dependencies = [
 "proc-macro2",
 "quote 1.0.42",
 "syn 2.0.111",
]

[[package]]
name = "tokio"
version = "1.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff360e02eab121e0bc37a2d3b4d4dc622e6eda3a8e5253d5435ecf5bd4c68408"
dependencies = [
 "bytes",
 "libc",
 "mio 1.1.1",
 "parking_lot",
 "pin-project-lite",
 "signal-hook-registry",
 "socket2",
 "tokio-macros",
 "windows-sys 0.61.2",
]

[[package]]
name = "tokio-macros"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "af407857209536a95c8e56f8231ef2c2e2aff839b22e07a1ffcbc617e9db9fa5"
dependencies = [
 "proc-macro2",
 "quote 1.0.42",
 "syn 2.0.111",
]

[[package]]
name = "tokio-util"
version = "0.7.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2efa149fe76073d6e8fd97ef4f4eca7b67f599660115591483572e406e165594"
dependencies = [
 "bytes",
 "futures-core",
 "futures-sink",
 "pin-project-lite",
 "tokio",
]

[[package]]
name = "tui"
version = "0.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccdd26cbd674007e649a272da4475fb666d3aa0ad0531da7136db6fab0e5bad1"
dependencies = [
 "bitflags 1.3.2",
 "cassowary",
 "termion",
 "unicode-segmentation",
 "unicode-width",
]

[[package]]
name = "tui-logger"
version = "0.9.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6b1616f71dcb909bb2d6507aabe679547a6b5ec5648fc0da64d524a4f3688e08"
dependencies = [
 "chrono",
 "fxhash",
 "lazy_static",
 "log",
 "parking_lot",
 "termion",
 "tui",
]

[[package]]
name = "unicode-ident"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9312f7c4f6ff9069b165498234ce8be658059c6728633667c526e27dc2cf1df5"

[[package]]
name = "unicode-segmentation"
version = "1.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6ccf251212114b54433ec949fd6a7841275f9ada20dddd2f29e9ceea4501493"

[[package]]
name = "unicode-truncate"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b3644627a5af5fa321c95b9b235a72fd24cd29c648c2c379431e6628655627bf"
dependencies = [
 "itertools 0.13.0",
 "unicode-segmentation",
 "unicode-width",
]

[[package]]
name = "unicode-width"
version = "0.1.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7dd6e30e90baa6f72411720665d41d89b9a3d039dc45b8faea1ddd07f617f6af"

[[package]]
name = "unicode-xid"
version = "0.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c1f860d7d29cf02cb2f3f359fd35991af3d30bac52c57d265a3c461074cb4dc"

[[package]]
name = "users"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24cc0f6d6f267b73e5a2cadf007ba8f9bc39c6a6f9666f8cf25ea809a153b032"
dependencies = [
 "libc",
 "log",
]

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "wasi"
version = "0.11.1+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"

[[package]]
name = "wasm-bindgen"
version = "0.2.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0d759f433fa64a2d763d1340820e46e111a7a5ab75f993d1852d70b03dbb80fd"
dependencies = [
 "cfg-if",
 "once_cell",
 "rustversion",
 "wasm-bindgen-macro",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48cb0d2638f8baedbc542ed444afc0644a29166f1595371af4fecf8ce1e7eeb3"
dependencies = [
 "quote 1.0.42",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cefb59d5cd5f92d9dcf80e4683949f15ca4b511f4ac0a6e14d4e1ac60c6ecd40"
dependencies = [
 "bumpalo",
 "proc-macro2",
 "quote 1.0.42",
 "syn 2.0.111",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cbc538057e648b67f72a982e708d485b2efa771e1ac05fec311f9f63e5800db4"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows-core"
version = "0.62.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8e83a14d34d0623b51dce9581199302a221863196a1dde71a7663a4c2be9deb"
dependencies = [
 "windows-implement",
 "windows-interface",
 "windows-link",
 "windows-result",
 "windows-strings",
]

[[package]]
name = "windows-implement"
version = "0.60.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "053e2e040ab57b9dc951b72c264860db7eb3b0200ba345b4e4c3b14f67855ddf"
dependencies = [
 "proc-macro2",
 "quote 1.0.42",
 "syn 2.0.111",
]

[[package]]
name = "windows-interface"
version = "0.59.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f316c4a2570ba26bbec722032c4099d8c8bc095efccdc15688708623367e358"
dependencies = [
 "proc-macro2",
 "quote 1.0.42",
 "syn 2.0.111",
]

[[package]]
name = "windows-link"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0805222e57f7521d6a62e36fa9163bc891acd422f971defe97d64e70d0a4fe5"

[[package]]
name = "windows-result"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7781fa89eaf60850ac3d2da7af8e5242a5ea78d1a11c49bf2910bb5a73853eb5"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-strings"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7837d08f69c77cf6b07689544538e017c1bfcf57e34b4c0ff58e6c2cd3b37091"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-sys"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
dependencies = [
 "windows-targets 0.48.5",
]

[[package]]
name = "windows-sys"
version = "0.60.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2f500e4d28234f72040990ec9d39e3a6b950f9f22d3dba18416c35882612bcb"
dependencies = [
 "windows-targets 0.53.5",
]

[[package]]
name = "windows-sys"
version = "0.61.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae137229bcbd6cdf0f7b80a31df61766145077ddf49416a728b02cb3921ff3fc"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-targets"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
dependencies = [
 "windows_aarch64_gnullvm 0.48.5",
 "windows_aarch64_msvc 0.48.5",
 "windows_i686_gnu 0.48.5",
 "windows_i686_msvc 0.48.5",
 "windows_x86_64_gnu 0.48.5",
 "windows_x86_64_gnullvm 0.48.5",
 "windows_x86_64_msvc 0.48.5",
]

[[package]]
name = "windows-targets"
version = "0.53.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4945f9f551b88e0d65f3db0bc25c33b8acea4d9e41163edf90dcd0b19f9069f3"
dependencies = [
 "windows-link",
 "windows_aarch64_gnullvm 0.53.1",
 "windows_aarch64_msvc 0.53.1",
 "windows_i686_gnu 0.53.1",
 "windows_i686_gnullvm",
 "windows_i686_msvc 0.53.1",
 "windows_x86_64_gnu 0.53.1",
 "windows_x86_64_gnullvm 0.53.1",
 "windows_x86_64_msvc 0.53.1",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a9d8416fa8b42f5c947f8482c43e7d89e73a173cead56d044f6a56104a6d1b53"

[[package]]
name = "windows_aarch64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"

[[package]]
name = "windows_aarch64_msvc"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9d782e804c2f632e395708e99a94275910eb9100b2114651e04744e9b125006"

[[package]]
name = "windows_i686_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"

[[package]]
name = "windows_i686_gnu"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "960e6da069d81e09becb0ca57a65220ddff016ff2d6af6a223cf372a506593a3"

[[package]]
name = "windows_i686_gnullvm"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa7359d10048f68ab8b09fa71c3daccfb0e9b559aed648a8f95469c27057180c"

[[package]]
name = "windows_i686_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"

[[package]]
name = "windows_i686_msvc"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e7ac75179f18232fe9c285163565a57ef8d3c89254a30685b57d83a38d326c2"

[[package]]
name = "windows_x86_64_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"

[[package]]
name = "windows_x86_64_gnu"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c3842cdd74a865a8066ab39c8a7a473c0778a3f29370b5fd6b4b9aa7df4a499"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ffa179e2d07eee8ad8f57493436566c7cc30ac536a3379fdf008f47f6bb7ae1"

[[package]]
name = "windows_x86_64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"

[[package]]
name = "windows_x86_64_msvc"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d6bbff5f0aada427a1e5a6da5f1f98158182f26556f345ac9e04d36d0ebed650"

```

`Cargo.toml`:

```toml
[package]
name = "d-shark"
version = "0.2.0"
edition = "2021"

[dependencies]
tokio = { version = "1.0", features = ["full"] }
tokio-util = { version = "0.7", features = ["codec"] }
clap = { version = "4.4", features = ["derive"] }
anyhow = "1.0"
log = "0.4"
tui-logger = "0.9"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
ratatui = "0.26"
crossterm = "0.27"
pcap-file = "1.1"
users = "0.11"
pretty-hex = "0.4"
chrono = "0.4"
glob = "0.3"
libc = "0.2"

# MODERN NETLINK STACK (Согласованные версии)
netlink-sys = "0.8"
netlink-packet-core = "0.7"
netlink-packet-sock-diag = "0.5"
netlink-packet-utils = "0.5" # ВАЖНО: Здесь живут трейты Emitable/Parseable
```

`src/analysis/mod.rs`:

```rs
pub mod process;
```

`src/analysis/process.rs`:

```rs
use std::collections::HashMap;
use std::fs;
use std::net::{IpAddr, Ipv4Addr};
use users::get_user_by_uid;
use anyhow::{Result, anyhow};

use netlink_sys::{Socket, protocols::NETLINK_SOCK_DIAG};
use netlink_packet_core::{
    NetlinkMessage, NetlinkHeader, 
    NLM_F_REQUEST, NLM_F_DUMP
};
use netlink_packet_utils::traits::{Emitable, Parseable}; // Новые трейты
use netlink_packet_sock_diag::{
    SockDiagMessage, 
    inet::{InetRequest, SocketId, StateFlags, ExtensionFlags},
    constants::{IPPROTO_TCP, IPPROTO_UDP, AF_INET},
};

pub struct SocketMap {
    pub tcp: HashMap<u16, ProcessInfo>,
    pub udp: HashMap<u16, ProcessInfo>,
}

#[derive(Clone, Debug)]
pub struct ProcessInfo {
    pub pid: u32,
    pub name: String,
    pub user: String,
}

impl SocketMap {
    pub fn new() -> Self {
        SocketMap {
            tcp: HashMap::new(),
            udp: HashMap::new(),
        }
    }

    pub fn update(&mut self) {
        let mut inode_to_port_tcp = HashMap::new();
        let mut inode_to_port_udp = HashMap::new();

        if let Ok(sockets) = fetch_sockets(IPPROTO_TCP) {
            for s in sockets { inode_to_port_tcp.insert(s.inode, s.port); }
        }
        if let Ok(sockets) = fetch_sockets(IPPROTO_UDP) {
            for s in sockets { inode_to_port_udp.insert(s.inode, s.port); }
        }

        if let Ok(entries) = fs::read_dir("/proc") {
            for entry in entries.flatten() {
                if entry.file_type().map(|t| t.is_dir()).unwrap_or(false) {
                    let pid_str = entry.file_name().to_string_lossy().to_string();
                    if let Ok(pid) = pid_str.parse::<u32>() {
                        self.scan_process(pid, &inode_to_port_tcp, &inode_to_port_udp);
                    }
                }
            }
        }
    }

    fn scan_process(&mut self, pid: u32, tcp_inodes: &HashMap<u32, u16>, udp_inodes: &HashMap<u32, u16>) {
        let fd_path = format!("/proc/{}/fd", pid);
        if let Ok(entries) = fs::read_dir(fd_path) {
            for fd_entry in entries.flatten() {
                if let Ok(target) = fs::read_link(fd_entry.path()) {
                    let target_str = target.to_string_lossy();
                    if target_str.starts_with("socket:[") {
                        let inode_str = target_str.trim_start_matches("socket:[").trim_end_matches(']');
                        if let Ok(inode) = inode_str.parse::<u32>() {
                            let mut info_cache = None;
                            // Helper to load info only once
                            let mut load_info = || {
                                if info_cache.is_none() {
                                    info_cache = Some(get_proc_details(pid));
                                }
                                info_cache.clone().unwrap()
                            };

                            if let Some(port) = tcp_inodes.get(&inode) {
                                let (name, user) = load_info();
                                self.tcp.insert(*port, ProcessInfo { pid, name, user });
                            }
                            if let Some(port) = udp_inodes.get(&inode) {
                                let (name, user) = load_info();
                                self.udp.insert(*port, ProcessInfo { pid, name, user });
                            }
                        }
                    }
                }
            }
        }
    }
}

struct RawSocketInfo {
    inode: u32,
    port: u16,
}

fn fetch_sockets(proto: u8) -> Result<Vec<RawSocketInfo>> {
    let mut socket = Socket::new(NETLINK_SOCK_DIAG)?;
    
    let mut header = NetlinkHeader::default();
    header.flags = NLM_F_REQUEST | NLM_F_DUMP;

    let payload = SockDiagMessage::InetRequest(InetRequest {
        family: AF_INET,
        protocol: proto,
        extensions: ExtensionFlags::empty(),
        states: StateFlags::all(),
        socket_id: SocketId {
            source_port: 0,
            destination_port: 0,
            source_address: IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)),
            destination_address: IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)),
            interface_id: 0,
            cookie: [0; 8],
        },
    });

    let mut packet = NetlinkMessage::new(header, payload);
    packet.finalize(); // Recalculate length

    // Use Emitable trait (new API)
    let mut buf = vec![0u8; packet.buffer_len()];
    packet.emit(&mut buf); 

    socket.send(&buf, 0)?;

    let mut results = Vec::new();
    let mut receive_buffer = vec![0u8; 8192];

    loop {
        let size = socket.recv(&mut receive_buffer, 0)?;
        let mut offset = 0;
        while offset < size {
            let bytes = &receive_buffer[offset..];
            // Use Parseable trait (new API)
            let rx_packet = <NetlinkMessage<SockDiagMessage>>::parse(bytes)
                .map_err(|e| anyhow!("Parse error: {}", e))?;

            match rx_packet.payload {
                netlink_packet_core::NetlinkPayload::InnerMessage(SockDiagMessage::InetResponse(response)) => {
                    results.push(RawSocketInfo {
                        inode: response.header.inode,
                        port: response.header.socket_id.source_port,
                    });
                }
                netlink_packet_core::NetlinkPayload::Done => return Ok(results),
                _ => {},
            }
            offset += rx_packet.header.length as usize;
            if offset >= size || rx_packet.header.length == 0 {
                offset = 0;
                break;
            }
        }
    }
}

fn get_proc_details(pid: u32) -> (String, String) {
    let name = fs::read_to_string(format!("/proc/{}/comm", pid))
        .unwrap_or_else(|_| "unknown".to_string()).trim().to_string();
    let uid = fs::read_to_string(format!("/proc/{}/loginuid", pid))
        .unwrap_or_default().trim().parse::<u32>().unwrap_or(0);
    let user = get_user_by_uid(uid).map(|u| u.name().to_string_lossy().to_string()).unwrap_or("root".into());
    (name, user)
}
```

`src/capture/engine.rs`:

```rs
use crate::capture::model::{Packet};
use crate::analysis::process::SocketMap; // Подключаем анализатор
use std::io::{BufRead, BufReader};
use std::process::{Command, Stdio, Child};
use std::sync::{Arc, Mutex, RwLock};
use std::thread;
use std::time::Duration;
use tokio::sync::mpsc::Sender;

#[derive(Clone)]
pub enum CaptureMode {
    Local(String),         
    Remote(String, String),
    File(String),          
}

pub struct CaptureEngine {
    mode: CaptureMode,
    stop_signal: Arc<Mutex<bool>>,
    socket_map: Arc<RwLock<SocketMap>>, // Общая память для процессов
}

impl CaptureEngine {
    pub fn new(mode: CaptureMode) -> Self {
        Self {
            mode,
            stop_signal: Arc::new(Mutex::new(false)),
            socket_map: Arc::new(RwLock::new(SocketMap::new())),
        }
    }

    pub fn start(&self, tx: Sender<Packet>) {
        let mode = self.mode.clone(); 
        let stop = self.stop_signal.clone();
        let sock_map = self.socket_map.clone();

        // 1. Thread: Process Monitor (Stratoshark logic)
        // Запускаем только для локального режима, так как /proc удаленный мы пока не читаем
        if let CaptureMode::Local(_) = mode {
            let stop_clone = stop.clone();
            let map_clone = sock_map.clone();
            thread::spawn(move || {
                loop {
                    if *stop_clone.lock().unwrap() { break; }
                    // Обновляем таблицу процессов
                    let mut map = map_clone.write().unwrap();
                    map.update();
                    drop(map);
                    thread::sleep(Duration::from_secs(1));
                }
            });
        }

        // 2. Thread: Packet Capture
        thread::spawn(move || {
            let mut child: Child = match mode {
                CaptureMode::Local(ref iface) => {
                    Command::new("tshark")
                        .args(&["-i", iface, "-T", "ek", "-l", "-n"]) 
                        .stdout(Stdio::piped())
                        .stderr(Stdio::null())
                        .spawn()
                        .expect("Failed to start tshark")
                },
                CaptureMode::File(ref path) => {
                    Command::new("tshark")
                        .args(&["-r", path, "-T", "ek", "-n"])
                        .stdout(Stdio::piped())
                        .spawn()
                        .expect("Failed to read pcap")
                },
                CaptureMode::Remote(ref host, ref iface) => {
                    let ssh_cmd = format!("tcpdump -U -s0 -w - -i {} not port 22", iface);
                    let ssh = Command::new("ssh")
                        .args(&["root@".to_owned() + host, ssh_cmd])
                        .stdout(Stdio::piped())
                        .spawn()
                        .expect("Failed SSH");

                    Command::new("tshark")
                        .args(&["-i", "-", "-T", "ek", "-l", "-n"])
                        .stdin(ssh.stdout.unwrap())
                        .stdout(Stdio::piped())
                        .spawn()
                        .expect("Failed Tshark")
                }
            };

            let stdout = child.stdout.take().unwrap();
            let reader = BufReader::new(stdout);
            let mut id_counter = 0;

            for line in reader.lines() {
                if *stop.lock().unwrap() { let _ = child.kill(); break; }

                if let Ok(json_line) = line {
                    if let Ok(parsed) = serde_json::from_str::<serde_json::Value>(&json_line) {
                        if parsed.get("index").is_some() { continue; }
                        id_counter += 1;
                        
                        let layers = parsed.get("layers");
                        if layers.is_none() { continue; }
                        let layers = layers.unwrap();

                        // Парсинг
                        let find_val = |p: &str, f: &str| -> Option<String> {
                             layers.get(p)?.get(f)?.as_array()?.get(0)?.as_str().map(|s| s.to_string())
                        };

                        let src = find_val("ip", "ip_ip_src").unwrap_or("?".into());
                        let dst = find_val("ip", "ip_ip_dst").unwrap_or("?".into());
                        let proto = find_val("frame", "frame_frame_protocols").unwrap_or("RAW".into())
                            .split(':').last().unwrap_or("UNK").to_uppercase();
                        
                        // Парсим порты для маппинга процессов
                        let src_port_s = find_val("tcp", "tcp_tcp_srcport").or_else(|| find_val("udp", "udp_udp_srcport")).unwrap_or("0".into());
                        let dst_port_s = find_val("tcp", "tcp_tcp_dstport").or_else(|| find_val("udp", "udp_udp_dstport")).unwrap_or("0".into());
                        
                        let src_port = src_port_s.parse::<u16>().unwrap_or(0);
                        let dst_port = dst_port_s.parse::<u16>().unwrap_or(0);

                        // Enrichment (Stratoshark)
                        let map = sock_map.read().unwrap();
                        let mut proc_name = None;
                        let mut pid = None;
                        let mut user = None;

                        // Ищем процесс, которому принадлежит локальный порт
                        // Проверяем Source Port (исходящий трафик)
                        if let Some(info) = map.tcp.get(&src_port).or(map.udp.get(&src_port)) {
                             proc_name = Some(info.name.clone());
                             pid = Some(info.pid);
                             user = Some(info.user.clone());
                        } 
                        // Проверяем Dest Port (входящий трафик)
                        else if let Some(info) = map.tcp.get(&dst_port).or(map.udp.get(&dst_port)) {
                             proc_name = Some(info.name.clone());
                             pid = Some(info.pid);
                             user = Some(info.user.clone());
                        }

                        let p = Packet {
                            id: id_counter,
                            timestamp: chrono::Local::now().format("%H:%M:%S").to_string(),
                            source: src,
                            destination: dst,
                            protocol: proto,
                            length: find_val("frame", "frame_frame_len").unwrap_or("0".into()),
                            info: format!("{} -> {}", src_port, dst_port),
                            src_port,
                            dst_port,
                            process_name: proc_name, // Использована существующая переменная
                            pid: pid,
                            user: user,
                            raw_data: vec![],
                            layers: Some(layers.clone()),
                        };

                        let _ = tx.blocking_send(p);
                    }
                }
            }
        });
    }

    pub fn stop(&self) {
        *self.stop_signal.lock().unwrap() = true;
    }
}
```

`src/capture/mod.rs`:

```rs
pub mod engine;
pub mod model;
```

`src/capture/model.rs`:

```rs
use serde::{Deserialize, Serialize};
use serde_json::Value;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Packet {
    pub id: usize,
    pub timestamp: String,
    pub source: String,
    pub destination: String,
    pub protocol: String,
    pub length: String,
    pub info: String,
    pub src_port: u16, // Добавили порты как числа для маппинга
    pub dst_port: u16,
    
    // Поля для Stratoshark (контекст)
    pub process_name: Option<String>,
    pub pid: Option<u32>,
    pub user: Option<String>,

    // Данные
    #[serde(skip)]
    pub raw_data: Vec<u8>,
    pub layers: Option<Value>,
}
```

`src/firewall.rs`:

```rs
use std::process::Command;
use anyhow::{Result, anyhow};
use log::info;

pub struct Firewall;

impl Firewall {
    /// Блокирует IP адрес через nftables
    pub fn block_ip(ip: &str) -> Result<()> {
        // 1. Проверяем, существует ли таблица (для простоты пытаемся создать)
        // В реальном Arch Linux nftables уже настроен, мы добавляем в цепочку input
        // Команда: nft add rule inet filter input ip saddr <IP> drop
        
        info!("🔥 FIREWALL: Blocking IP {}", ip);

        // Мы используем 'inet filter' как стандартную таблицу. 
        // Если её нет, команда упадет, но для MVP считаем, что окружение подготовлено.
        let status = Command::new("nft")
            .args(&["add", "rule", "inet", "filter", "input", "ip", "saddr", ip, "drop"])
            .status();

        match status {
            Ok(s) if s.success() => Ok(()),
            Ok(_) => Err(anyhow!("Failed to add nftables rule (check permissions/tables)")),
            Err(e) => Err(anyhow!("Failed to execute nft: {}", e)),
        }
    }

    /// Блокирует порт (TCP)
    pub fn block_port(port: &str) -> Result<()> {
        info!("🔥 FIREWALL: Blocking Port {}", port);
        
        let status = Command::new("nft")
            .args(&["add", "rule", "inet", "filter", "input", "tcp", "dport", port, "drop"])
            .status();

        match status {
            Ok(s) if s.success() => Ok(()),
            _ => Err(anyhow!("Failed to block port")),
        }
    }
}
```

`src/main.rs`:

```rs
use clap::Parser;
use crossterm::{
    event::{self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode, MouseEventKind},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{
    backend::{Backend, CrosstermBackend},
    layout::{Constraint, Direction, Layout},
    style::{Color, Modifier, Style},
    text::{Span, Line},
    widgets::{Block, Borders, List, ListItem, Paragraph, Wrap, Tabs},
    Terminal, Frame,
};
use std::{io, time::Duration};
use tokio::sync::mpsc;

mod capture;
mod ui;
mod firewall;
mod analysis; // <--- Новый модуль

use capture::engine::{CaptureEngine, CaptureMode};
use capture::model::Packet;
use ui::app::App;

#[derive(Parser)]
struct Cli {
    #[arg(short, long, default_value = "eth0")]
    interface: String,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let cli = Cli::parse();

    enable_raw_mode()?;
    let mut stdout = io::stdout();
    execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;

    let (tx, mut rx) = mpsc::channel::<Packet>(500);
    let engine = CaptureEngine::new(CaptureMode::Local(cli.interface.clone()));
    engine.start(tx);

    let mut app = App::new();
    let res = run_app(&mut terminal, &mut app, &mut rx).await;

    disable_raw_mode()?;
    execute!(terminal.backend_mut(), LeaveAlternateScreen, DisableMouseCapture)?;
    terminal.show_cursor()?;

    if let Err(err) = res { println!("{:?}", err) }
    Ok(())
}

async fn run_app<B: Backend>(
    terminal: &mut Terminal<B>,
    app: &mut App,
    rx: &mut mpsc::Receiver<Packet>,
) -> io::Result<()> {
    loop {
        terminal.draw(|f| ui_draw(f, app))?;

        for _ in 0..50 {
            if let Ok(p) = rx.try_recv() { app.on_packet(p); } else { break; }
        }

        if event::poll(Duration::from_millis(30))? {
            match event::read()? {
                Event::Key(key) => match key.code {
                    KeyCode::Char('q') => return Ok(()),
                    KeyCode::Down => app.next(),
                    KeyCode::Up => app.previous(),
                    KeyCode::Enter => app.toggle_details(),
                    KeyCode::Char('b') => app.block_selected_ip(),
                    KeyCode::End => app.auto_scroll = true,
                    KeyCode::Tab => app.show_details = !app.show_details, // Переключение вида
                    _ => {}
                },
                Event::Mouse(mouse) => match mouse.kind {
                    MouseEventKind::ScrollDown => app.next(),
                    MouseEventKind::ScrollUp => app.previous(),
                    _ => {}
                },
                _ => {}
            }
        }
    }
}

fn ui_draw(f: &mut Frame, app: &mut App) {
    let main_chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([Constraint::Length(3), Constraint::Min(0)].as_ref())
        .split(f.size());

    // --- Header / Tabs ---
    let titles = vec![" Network (Wireshark) ", " Process (Stratoshark) "];
    let tabs = Tabs::new(titles)
        .block(Block::default().borders(Borders::ALL).title(" d-shark v0.2 "))
        .highlight_style(Style::default().fg(Color::Yellow))
        .select(if app.show_details { 1 } else { 0 }); // Условно используем show_details как переключатель вида
    f.render_widget(tabs, main_chunks[0]);

    // --- Content ---
    let constraints = if app.show_details {
        // Stratoshark View (Список + Детали процесса)
        vec![Constraint::Percentage(60), Constraint::Percentage(40)]
    } else {
        // Wireshark View (Только список)
        vec![Constraint::Percentage(100)]
    };
    
    let content_chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints(constraints)
        .split(main_chunks[1]);

    // LIST VIEW
    let items: Vec<ListItem> = app.packets.iter().map(|p| {
        // Wireshark Colors Logic
        let (fg, bg) = match p.protocol.as_str() {
            "TCP" => (Color::Black, Color::LightGreen),  // #E4FFC7
            "UDP" => (Color::Black, Color::LightBlue),   // #DAEEFF
            "HTTP" => (Color::Black, Color::Green),
            "TLS" => (Color::Black, Color::LightMagenta),
            "ARP" => (Color::Black, Color::Yellow),
            "ICMP" => (Color::Black, Color::LightCyan),
            "DNS" => (Color::Black, Color::LightBlue),
            _ => (Color::White, Color::Reset),
        };

        // Формируем строку
        let mut spans = vec![
            Span::raw(format!("{} ", p.timestamp)),
            Span::styled(format!("{:<15}", p.source), Style::default().fg(fg).bg(bg)),
            Span::raw(" -> "),
            Span::styled(format!("{:<15}", p.destination), Style::default().fg(fg).bg(bg)),
            Span::raw(" | "),
            Span::styled(format!("{:<5}", p.protocol), Style::default().add_modifier(Modifier::BOLD).fg(fg).bg(bg)),
        ];

        // Stratoshark info
        if let Some(proc) = &p.process_name {
            spans.push(Span::raw(" ["));
            spans.push(Span::styled(proc, Style::default().fg(Color::Red).add_modifier(Modifier::BOLD)));
            spans.push(Span::raw(format!(":{}]", p.pid.unwrap_or(0))));
        }

        ListItem::new(Line::from(spans))
    }).collect();

    let list = List::new(items)
        .block(Block::default().borders(Borders::ALL).title(" Live Capture "))
        .highlight_style(Style::default().add_modifier(Modifier::BOLD).bg(Color::DarkGray))
        .highlight_symbol(">> ");

    f.render_stateful_widget(list, content_chunks[0], &mut app.state);

    // DETAILS VIEW (Если Tab нажат)
    if app.show_details {
        if let Some(idx) = app.state.selected() {
            if let Some(p) = app.packets.get(idx) {
                let mut text = format!("Packet Details #{}\n", p.id);
                if let Some(proc) = &p.process_name {
                    text += &format!("\nProcess: {} (PID: {})\nUser: {}\n", proc, p.pid.unwrap_or(0), p.user.as_deref().unwrap_or("?"));
                } else {
                    text += "\nProcess: Unknown (short-lived or kernel thread)\n";
                }
                
                if let Some(l) = &p.layers {
                    text += &format!("\nL7 Data:\n{}", serde_json::to_string_pretty(l).unwrap_or("".into()));
                }

                let p_widget = Paragraph::new(text)
                    .block(Block::default().borders(Borders::ALL).title(" Deep Inspection "))
                    .wrap(Wrap { trim: false });
                f.render_widget(p_widget, content_chunks[1]);
            }
        }
    }
}
```

`src/ui/app.rs`:

```rs
use crate::capture::model::Packet;
use crate::firewall::Firewall;
use ratatui::widgets::ListState; // Используем правильный импорт

pub struct App {
    pub packets: Vec<Packet>,
    pub state: ListState,
    pub auto_scroll: bool,
    pub show_details: bool,
    pub should_quit: bool,
}

impl App {
    pub fn new() -> App {
        App {
            packets: Vec::new(),
            state: ListState::default(),
            auto_scroll: true,
            show_details: false,
            should_quit: false,
        }
    }

    pub fn on_packet(&mut self, p: Packet) {
        self.packets.push(p);
        if self.auto_scroll {
            self.state.select(Some(self.packets.len() - 1));
        }
    }

    pub fn next(&mut self) {
        let i = match self.state.selected() {
            Some(i) => {
                if i >= self.packets.len() - 1 { i } else { i + 1 }
            }
            None => 0,
        };
        self.state.select(Some(i));
        self.auto_scroll = false;
    }

    pub fn previous(&mut self) {
        let i = match self.state.selected() {
            Some(i) => {
                if i == 0 { 0 } else { i - 1 }
            }
            None => 0,
        };
        self.state.select(Some(i));
        self.auto_scroll = false;
    }

    pub fn toggle_details(&mut self) {
        self.show_details = !self.show_details;
    }

    pub fn block_selected_ip(&self) {
        if let Some(idx) = self.state.selected() {
            if let Some(p) = self.packets.get(idx) {
                if p.source != "?" && p.source != "127.0.0.1" {
                    let _ = Firewall::block_ip(&p.source);
                }
            }
        }
    }
}
```

`src/ui/mod.rs`:

```rs
pub mod app;
```