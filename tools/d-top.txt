Project Path: d-top

Source Tree:

```txt
d-top
‚îú‚îÄ‚îÄ cmd
‚îÇ   ‚îî‚îÄ‚îÄ d-top
‚îÇ       ‚îî‚îÄ‚îÄ main.go
‚îú‚îÄ‚îÄ d-top
‚îú‚îÄ‚îÄ go.mod
‚îú‚îÄ‚îÄ go.sum
‚îî‚îÄ‚îÄ internal
    ‚îú‚îÄ‚îÄ app
    ‚îÇ   ‚îî‚îÄ‚îÄ model.go
    ‚îú‚îÄ‚îÄ redteam
    ‚îÇ   ‚îî‚îÄ‚îÄ stealth.go
    ‚îî‚îÄ‚îÄ views
        ‚îú‚îÄ‚îÄ infra.go
        ‚îî‚îÄ‚îÄ redteam.go

```

`cmd/d-top/main.go`:

```go
package main

import (
	"fmt"
	"os"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/devos-os/d-top/internal/app"
)

func main() {
	p := tea.NewProgram(app.NewModel(), tea.WithAltScreen())
	if _, err := p.Run(); err != nil {
		fmt.Printf("Error: %v", err)
		os.Exit(1)
	}
}
```

`go.mod`:

```mod
module github.com/devos-os/d-top

go 1.25.5

require (
	github.com/charmbracelet/bubbles v0.21.0
	github.com/charmbracelet/bubbletea v1.3.10
	github.com/charmbracelet/lipgloss v1.1.0
	github.com/docker/docker v24.0.7+incompatible
)

require (
	github.com/Microsoft/go-winio v0.4.21 // indirect
	github.com/atotto/clipboard v0.1.4 // indirect
	github.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect
	github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc // indirect
	github.com/charmbracelet/x/ansi v0.10.1 // indirect
	github.com/charmbracelet/x/cellbuf v0.0.13-0.20250311204145-2c3ea96c31dd // indirect
	github.com/charmbracelet/x/term v0.2.1 // indirect
	github.com/docker/distribution v0.0.0-00010101000000-000000000000 // indirect
	github.com/docker/go-connections v0.6.0 // indirect
	github.com/docker/go-units v0.5.0 // indirect
	github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f // indirect
	github.com/gogo/protobuf v1.3.2 // indirect
	github.com/google/go-cmp v0.6.0 // indirect
	github.com/lucasb-eyer/go-colorful v1.2.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mattn/go-localereader v0.0.1 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/moby/term v0.5.2 // indirect
	github.com/morikuni/aec v1.1.0 // indirect
	github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect
	github.com/muesli/cancelreader v0.2.2 // indirect
	github.com/muesli/termenv v0.16.0 // indirect
	github.com/opencontainers/go-digest v1.0.0 // indirect
	github.com/opencontainers/image-spec v1.1.1 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/sahilm/fuzzy v0.1.1 // indirect
	github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e // indirect
	golang.org/x/sys v0.39.0 // indirect
	golang.org/x/text v0.32.0 // indirect
	golang.org/x/time v0.14.0 // indirect
	gotest.tools/v3 v3.5.2 // indirect
)

replace github.com/docker/docker => github.com/docker/docker v24.0.7+incompatible

replace github.com/docker/distribution => github.com/docker/distribution v2.8.2+incompatible

```

`go.sum`:

```sum
github.com/Azure/go-ansiterm v0.0.0-20250102033503-faa5f7b0171c h1:udKWzYgxTojEKWjV8V+WSxDXJ4NFATAsZjh8iIbsQIg=
github.com/Azure/go-ansiterm v0.0.0-20250102033503-faa5f7b0171c/go.mod h1:xomTg63KZ2rFqZQzSB4Vz2SUXa1BpHTVz9L5PTmPC4E=
github.com/Microsoft/go-winio v0.4.21 h1:+6mVbXh4wPzUrl1COX9A+ZCvEpYsOBZ6/+kwDnvLyro=
github.com/Microsoft/go-winio v0.4.21/go.mod h1:JPGBdM1cNvN/6ISo+n8V5iA4v8pBzdOpzfwIujj1a84=
github.com/atotto/clipboard v0.1.4 h1:EH0zSVneZPSuFR11BlR9YppQTVDbh5+16AmcJi4g1z4=
github.com/atotto/clipboard v0.1.4/go.mod h1:ZY9tmq7sm5xIbd9bOK4onWV4S6X0u6GY7Vn0Yu86PYI=
github.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=
github.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=
github.com/aymanbagabas/go-udiff v0.2.0 h1:TK0fH4MteXUDspT88n8CKzvK0X9O2xu9yQjWpi6yML8=
github.com/aymanbagabas/go-udiff v0.2.0/go.mod h1:RE4Ex0qsGkTAJoQdQQCA0uG+nAzJO/pI/QwceO5fgrA=
github.com/charmbracelet/bubbles v0.21.0 h1:9TdC97SdRVg/1aaXNVWfFH3nnLAwOXr8Fn6u6mfQdFs=
github.com/charmbracelet/bubbles v0.21.0/go.mod h1:HF+v6QUR4HkEpz62dx7ym2xc71/KBHg+zKwJtMw+qtg=
github.com/charmbracelet/bubbletea v1.3.10 h1:otUDHWMMzQSB0Pkc87rm691KZ3SWa4KUlvF9nRvCICw=
github.com/charmbracelet/bubbletea v1.3.10/go.mod h1:ORQfo0fk8U+po9VaNvnV95UPWA1BitP1E0N6xJPlHr4=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc h1:4pZI35227imm7yK2bGPcfpFEmuY1gc2YSTShr4iJBfs=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc/go.mod h1:X4/0JoqgTIPSFcRA/P6INZzIuyqdFY5rm8tb41s9okk=
github.com/charmbracelet/lipgloss v1.1.0 h1:vYXsiLHVkK7fp74RkV7b2kq9+zDLoEU4MZoFqR/noCY=
github.com/charmbracelet/lipgloss v1.1.0/go.mod h1:/6Q8FR2o+kj8rz4Dq0zQc3vYf7X+B0binUUBwA0aL30=
github.com/charmbracelet/x/ansi v0.10.1 h1:rL3Koar5XvX0pHGfovN03f5cxLbCF2YvLeyz7D2jVDQ=
github.com/charmbracelet/x/ansi v0.10.1/go.mod h1:3RQDQ6lDnROptfpWuUVIUG64bD2g2BgntdxH0Ya5TeE=
github.com/charmbracelet/x/cellbuf v0.0.13-0.20250311204145-2c3ea96c31dd h1:vy0GVL4jeHEwG5YOXDmi86oYw2yuYUGqz6a8sLwg0X8=
github.com/charmbracelet/x/cellbuf v0.0.13-0.20250311204145-2c3ea96c31dd/go.mod h1:xe0nKWGd3eJgtqZRaN9RjMtK7xUYchjzPr7q6kcvCCs=
github.com/charmbracelet/x/exp/golden v0.0.0-20241011142426-46044092ad91 h1:payRxjMjKgx2PaCWLZ4p3ro9y97+TVLZNaRZgJwSVDQ=
github.com/charmbracelet/x/exp/golden v0.0.0-20241011142426-46044092ad91/go.mod h1:wDlXFlCrmJ8J+swcL/MnGUuYnqgQdW9rhSD61oNMb6U=
github.com/charmbracelet/x/term v0.2.1 h1:AQeHeLZ1OqSXhrAWpYUtZyX1T3zVxfpZuEQMIQaGIAQ=
github.com/charmbracelet/x/term v0.2.1/go.mod h1:oQ4enTYFV7QN4m0i9mzHrViD7TQKvNEEkHUMCmsxdUg=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/docker/distribution v2.8.2+incompatible h1:T3de5rq0dB1j30rp0sA2rER+m322EBzniBPB6ZIzuh8=
github.com/docker/distribution v2.8.2+incompatible/go.mod h1:J2gT2udsDAN96Uj4KfcMRqY0/ypR+oyYUYmja8H+y+w=
github.com/docker/docker v24.0.7+incompatible h1:Wo6l37AuwP3JaMnZa226lzVXGA3F9Ig1seQen0cKYlM=
github.com/docker/docker v24.0.7+incompatible/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=
github.com/docker/go-connections v0.6.0 h1:LlMG9azAe1TqfR7sO+NJttz1gy6KO7VJBh+pMmjSD94=
github.com/docker/go-connections v0.6.0/go.mod h1:AahvXYshr6JgfUJGdDCs2b5EZG/vmaMAntpSFH5BFKE=
github.com/docker/go-units v0.5.0 h1:69rxXcBk27SvSaaxTtLh/8llcHD8vYHT7WSdRZ/jvr4=
github.com/docker/go-units v0.5.0/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f h1:Y/CXytFA4m6baUTXGLOoWe4PQhGxaX0KpnayAqC48p4=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f/go.mod h1:vw97MGsxSvLiUE2X8qFplwetxpGLQrlU1Q9AUEIzCaM=
github.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=
github.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=
github.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=
github.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=
github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
github.com/kylelemons/godebug v1.1.0 h1:RPNrshWIDI6G2gRW9EHilWtl7Z6Sb1BR0xunSBf0SNc=
github.com/kylelemons/godebug v1.1.0/go.mod h1:9/0rRGxNHcop5bhtWyNeEfOS8JIWk580+fNqagV/RAw=
github.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=
github.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mattn/go-localereader v0.0.1 h1:ygSAOl7ZXTx4RdPYinUpg6W99U8jWvWi9Ye2JC/oIi4=
github.com/mattn/go-localereader v0.0.1/go.mod h1:8fBrzywKY7BI3czFoHkuzRoWE9C+EiG4R1k4Cjx5p88=
github.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=
github.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/moby/term v0.5.2 h1:6qk3FJAFDs6i/q3W/pQ97SX192qKfZgGjCQqfCJkgzQ=
github.com/moby/term v0.5.2/go.mod h1:d3djjFCrjnB+fl8NJux+EJzu0msscUP+f8it8hPkFLc=
github.com/morikuni/aec v1.1.0 h1:vBBl0pUnvi/Je71dsRrhMBtreIqNMYErSAbEeb8jrXQ=
github.com/morikuni/aec v1.1.0/go.mod h1:xDRgiq/iw5l+zkao76YTKzKttOp2cwPEne25HDkJnBw=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 h1:ZK8zHtRHOkbHy6Mmr5D264iyp3TiX5OmNcI5cIARiQI=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6/go.mod h1:CJlz5H+gyd6CUWT45Oy4q24RdLyn7Md9Vj2/ldJBSIo=
github.com/muesli/cancelreader v0.2.2 h1:3I4Kt4BQjOR54NavqnDogx/MIoWBFa0StPA8ELUXHmA=
github.com/muesli/cancelreader v0.2.2/go.mod h1:3XuTXfFS2VjM+HTLZY9Ak0l6eUKfijIfMUZ4EgX0QYo=
github.com/muesli/termenv v0.16.0 h1:S5AlUN9dENB57rsbnkPyfdGuWIlkmzJjbFf0Tf5FWUc=
github.com/muesli/termenv v0.16.0/go.mod h1:ZRfOIKPFDYQoDFF4Olj7/QJbW60Ol/kL1pU3VfY/Cnk=
github.com/opencontainers/go-digest v1.0.0 h1:apOUWs51W5PlhuyGyz9FCeeBIOUDA/6nW8Oi/yOhh5U=
github.com/opencontainers/go-digest v1.0.0/go.mod h1:0JzlMkj0TRzQZfJkVvzbP0HBR3IKzErnv2BNG4W4MAM=
github.com/opencontainers/image-spec v1.1.1 h1:y0fUlFfIZhPF1W537XOLg0/fcx6zcHCJwooC2xJA040=
github.com/opencontainers/image-spec v1.1.1/go.mod h1:qpqAh3Dmcf36wStyyWU+kCeDgrGnAve2nCC8+7h8Q0M=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=
github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/sahilm/fuzzy v0.1.1 h1:ceu5RHF8DGgoi+/dR5PsECjCDH1BE3Fnmpo7aVXOdRA=
github.com/sahilm/fuzzy v0.1.1/go.mod h1:VFvziUEIMCrT6A6tw2RFIXPXXmzXbOsSHF0DOI8ZK9Y=
github.com/sirupsen/logrus v1.7.0/go.mod h1:yWOB1SBYBC5VeMP7gHvWumXLIWorT60ONWic61uBYv0=
github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e h1:JVG44RsyaB9T2KIHavMF/ppJZNG9ZpyihvCd0w101no=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e/go.mod h1:RbqR21r5mrJuqunuUZ/Dhy/avygyECGrLceyNeo4LiM=
github.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
github.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/exp v0.0.0-20220909182711-5c715a9e8561 h1:MDc5xs78ZrZr3HMQugiXOAkSZtfTpbJLDr/lwfgO53E=
golang.org/x/exp v0.0.0-20220909182711-5c715a9e8561/go.mod h1:cyybsKvd6eL0RnXn6p/Grxp8F5bW7iYuBgsNCOHpMYE=
golang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210124154548-22da62e12c0c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.39.0 h1:CvCKL8MeisomCi6qNZ+wbb0DN9E5AATixKsvNtMoMFk=
golang.org/x/sys v0.39.0/go.mod h1:OgkHotnGiDImocRcuBABYBEXf8A9a87e/uXjp9XT3ks=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.32.0 h1:ZD01bjUt1FQ9WJ0ClOL5vxgxOI/sVCNgX1YtKwcY0mU=
golang.org/x/text v0.32.0/go.mod h1:o/rUWzghvpD5TXrTIBuJU77MTaN0ljMWE47kxGJQ7jY=
golang.org/x/time v0.14.0 h1:MRx4UaLrDotUKUdCIqzPC48t1Y9hANFKIRpNx+Te8PI=
golang.org/x/time v0.14.0/go.mod h1:eL/Oa2bBBK0TkX57Fyni+NgnyQQN4LitPmob2Hjnqw4=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
golang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
gotest.tools/v3 v3.5.2 h1:7koQfIKdy+I8UTetycgUqXWSDwpgv193Ka+qRsmBY8Q=
gotest.tools/v3 v3.5.2/go.mod h1:LtdLGcnqToBH83WByAAi/wiwSFCArdFIUV/xxN4pcjA=

```

`internal/app/model.go`:

```go
package app

import (
	"fmt"
	"os/exec"
	"strings"
	"os"
	"github.com/charmbracelet/bubbles/list"
	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/devos-os/d-top/internal/views"
)

// --- –°—Ç–∏–ª–∏ ---
var (
	docStyle      = lipgloss.NewStyle().Margin(1, 2)
	focusedStyle  = lipgloss.NewStyle().Foreground(lipgloss.Color("205"))
	noStyle       = lipgloss.NewStyle()
	
	titleStyle    = lipgloss.NewStyle().Foreground(lipgloss.Color("#FFF7DB")).Background(lipgloss.Color("#888B7E")).Padding(0, 1)
	helpStyle     = lipgloss.NewStyle().Foreground(lipgloss.Color("241")).MarginTop(1)
)

type toolFinishedMsg struct{ err error }

// –°–æ—Å—Ç–æ—è–Ω–∏—è
const (
	stateMenu sessionState = iota
	stateConnectForm
	stateInfra
	stateRedTeam
)
type sessionState int

type Model struct {
	state        sessionState
	list         list.Model
	inputs       []textinput.Model 
	focusIndex   int
	
	infraModel   *views.InfraModel
	redModel     *views.RedTeamModel
	
	connected    bool
	sshConfig    views.SSHConfig
	socketPath   string
	
	choice       string
	quitting     bool
	err          error
}

type item struct { title, desc, id string; locked bool }
func (i item) Title() string { 
	if i.locked { return "üîí " + i.title }
	return i.title 
}
func (i item) Description() string { return i.desc }
func (i item) FilterValue() string { return i.title }

func NewModel() Model {
	items := []list.Item{
		item{title: "Connect", desc: "Establish Master Session", id: "connect"},
		item{title: "Local Monitor", desc: "Run btop locally", id: "local"},
		item{title: "Infrastructure", desc: "Docker Dashboard", id: "infra"},
		item{title: "Remote Monitor", desc: "View remote stats", id: "remote", locked: true},
		item{title: "Red Team Ops", desc: "Process manipulation", id: "red", locked: true},
	}
	
	l := list.New(items, list.NewDefaultDelegate(), 0, 0)
	l.Title = "d-top: Control Center"

	inputs := make([]textinput.Model, 5)
	inputs[0] = textinput.New(); inputs[0].Placeholder = "127.0.0.1"; inputs[0].Prompt = "Host:     "
	inputs[1] = textinput.New(); inputs[1].Placeholder = "root";      inputs[1].Prompt = "User:     "
	inputs[2] = textinput.New(); inputs[2].Placeholder = "2222";      inputs[2].Prompt = "Port:     "
	inputs[3] = textinput.New(); inputs[3].Placeholder = "Password";  inputs[3].Prompt = "Password: "; inputs[3].EchoMode = textinput.EchoPassword; inputs[3].EchoCharacter = '‚Ä¢'
	inputs[4] = textinput.New(); inputs[4].SetValue("Standard");      inputs[4].Prompt = "Mode:     "

	m := Model{
		state:      stateMenu,
		list:       l,
		inputs:     inputs,
		infraModel: views.NewInfraModel(),
		redModel:   views.NewRedTeamModel(),
		socketPath: fmt.Sprintf("/tmp/d-top-ssh-%d.sock", os.Getpid()),
	}
	m.updateMenuItems()
	return m
}

func (m *Model) updateMenuItems() {
	items := []list.Item{
		item{title: "Connect", desc: "Establish Master Session", id: "connect"},
		item{title: "Local Monitor", desc: "Run btop locally", id: "local"},
		item{title: "Infrastructure", desc: "Docker Dashboard", id: "infra"},
		item{title: "Remote Monitor", desc: "View remote stats", id: "remote", locked: !m.connected},
		item{title: "Red Team Ops", desc: "Process manipulation", id: "red", locked: !m.connected},
	}
	m.list.SetItems(items)
}

func (m Model) Init() tea.Cmd {
	return tea.Batch(
		m.infraModel.Init(),
		m.redModel.Init(),
	)
}

func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd
	var cmds []tea.Cmd

	switch msg := msg.(type) {
	
	case toolFinishedMsg:
		m.choice = ""
		if m.state == stateConnectForm && msg.err == nil {
			m.connected = true
			m.updateMenuItems()
			m.state = stateMenu
		}
		if msg.err != nil { m.err = msg.err }
		return m, tea.Batch(tea.ClearScreen)

	case tea.KeyMsg:
		if m.state == stateMenu && (msg.String() == "q" || msg.String() == "ctrl+c") {
			_ = exec.Command("ssh", "-S", m.socketPath, "-O", "exit", "dummy").Run()
			return m, tea.Quit
		}
		if (m.state == stateInfra || m.state == stateRedTeam) && msg.String() == "esc" {
			m.state = stateMenu
			return m, nil
		}

	// –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü–µ—Ä–µ–¥–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã –æ–∫–Ω–∞ –≤–æ –≤—Å–µ –ø–æ–¥-–º–æ–¥–µ–ª–∏!
	case tea.WindowSizeMsg:
		// 1. –û–±–Ω–æ–≤–ª—è–µ–º –º–µ–Ω—é
		m.list.SetWidth(msg.Width)
		m.list.SetHeight(msg.Height)
		
		// 2. –û–±–Ω–æ–≤–ª—è–µ–º Infra Model (—ç—Ç–æ –ø–æ—á–∏–Ω–∏—Ç –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã)
		var iModel tea.Model
		iModel, cmd = m.infraModel.Update(msg)
		m.infraModel = iModel.(*views.InfraModel)
		cmds = append(cmds, cmd)

		// 3. –û–±–Ω–æ–≤–ª—è–µ–º Red Team Model
		var rModel tea.Model
		rModel, cmd = m.redModel.Update(msg)
		m.redModel = rModel.(*views.RedTeamModel)
		cmds = append(cmds, cmd)
		
		return m, tea.Batch(cmds...)
	}

	switch m.state {
	case stateMenu:
		switch msg := msg.(type) {
		case tea.KeyMsg:
			if msg.String() == "enter" {
				i, ok := m.list.SelectedItem().(item)
				if ok {
					if i.locked { return m, nil }
					switch i.id {
					case "connect":
						m.state = stateConnectForm
						m.inputs[0].Focus()
						return m, nil
					case "remote":
						return m.launchRemoteBtop()
					case "local":
						return m.runLocalBtop()
					case "infra":
						m.state = stateInfra
						// Force resize on enter just in case
						// m.infraModel.Update(tea.WindowSizeMsg{Width: m.list.Width(), Height: m.list.Height()})
						return m, m.infraModel.Refresh()
					case "red":
						m.state = stateRedTeam
						m.redModel.SetConnection(&m.sshConfig)
						m.sshConfig.SocketPath = m.socketPath
						return m, m.redModel.Refresh()
					}
				}
			}
		}
		m.list, cmd = m.list.Update(msg)
		cmds = append(cmds, cmd)

	case stateConnectForm:
		switch msg := msg.(type) {
		case tea.KeyMsg:
			if msg.String() == "esc" { m.state = stateMenu; return m, nil }
			if m.focusIndex == 4 && msg.String() == " " {
				if m.inputs[4].Value() == "Standard" { m.inputs[4].SetValue("Stealth (Red Team)") } else { m.inputs[4].SetValue("Standard") }
				return m, nil
			}
			if msg.String() == "enter" && m.focusIndex == len(m.inputs) {
				return m.startMasterSession()
			}
			if msg.String() == "tab" || msg.String() == "down" { m.focusIndex = (m.focusIndex + 1) % (len(m.inputs) + 1); return m, m.updateInputsFocus() }
			if msg.String() == "shift+tab" || msg.String() == "up" { m.focusIndex--; if m.focusIndex < 0 { m.focusIndex = len(m.inputs) }; return m, m.updateInputsFocus() }
		}
		for i := range m.inputs { if i != 4 { m.inputs[i], cmd = m.inputs[i].Update(msg) } }
		return m, cmd

	case stateInfra:
		var model tea.Model
		model, cmd = m.infraModel.Update(msg)
		m.infraModel = model.(*views.InfraModel)
		cmds = append(cmds, cmd)
	
	case stateRedTeam:
		var model tea.Model
		model, cmd = m.redModel.Update(msg)
		m.redModel = model.(*views.RedTeamModel)
		cmds = append(cmds, cmd)
	}

	return m, tea.Batch(cmds...)
}

func (m *Model) startMasterSession() (tea.Model, tea.Cmd) {
	m.sshConfig = views.SSHConfig{
		Host: m.inputs[0].Value(),
		User: m.inputs[1].Value(),
		Port: m.inputs[2].Value(),
		Stealth: strings.Contains(m.inputs[4].Value(), "Stealth"),
		SocketPath: m.socketPath,
	}
	password := m.inputs[3].Value()

	os.Remove(m.socketPath)

	sshArgs := []string{
		"-M", "-S", m.socketPath, 
		"-p", m.sshConfig.Port,
		"-o", "ControlPersist=yes",
		"-N",
	}
	
	if m.sshConfig.Stealth {
		sshArgs = append(sshArgs, "-o", "UserKnownHostsFile=/dev/null", "-o", "StrictHostKeyChecking=no")
	}
	
	target := fmt.Sprintf("%s@%s", m.sshConfig.User, m.sshConfig.Host)
	sshArgs = append(sshArgs, target)

	var c *exec.Cmd
	if password != "" {
		finalArgs := append([]string{"-p", password, "ssh"}, sshArgs...)
		c = exec.Command("sshpass", finalArgs...)
	} else {
		c = exec.Command("ssh", sshArgs...)
	}
	
	return m, tea.ExecProcess(c, func(err error) tea.Msg {
		if _, statErr := os.Stat(m.socketPath); statErr == nil {
			return toolFinishedMsg{nil}
		}
		return toolFinishedMsg{fmt.Errorf("connection failed")}
	})
}

func (m *Model) runLocalBtop() (tea.Model, tea.Cmd) {
	m.choice = "local"
	c := exec.Command("btop")
	return m, tea.ExecProcess(c, func(err error) tea.Msg { return toolFinishedMsg{err} })
}

func (m *Model) launchRemoteBtop() (tea.Model, tea.Cmd) {
	args := []string{"-S", m.socketPath, "-t", fmt.Sprintf("%s@%s", m.sshConfig.User, m.sshConfig.Host), "btop"}
	c := exec.Command("ssh", args...)
	m.choice = "remote"
	return m, tea.ExecProcess(c, func(err error) tea.Msg { return toolFinishedMsg{err} })
}

func (m *Model) updateInputsFocus() tea.Cmd {
	cmds := make([]tea.Cmd, len(m.inputs))
	for i := 0; i < len(m.inputs); i++ {
		if i == m.focusIndex { cmds[i] = m.inputs[i].Focus(); m.inputs[i].PromptStyle = focusedStyle } else { m.inputs[i].Blur(); m.inputs[i].PromptStyle = noStyle }
	}
	return tea.Batch(cmds...)
}

func (m Model) View() string {
	if m.choice != "" { return "" }
	if m.state == stateMenu { return docStyle.Render(m.list.View()) }
	if m.state == stateConnectForm {
		var b strings.Builder
		b.WriteString(titleStyle.Render(" SSH Master Connection ") + "\n\n")
		for i := range m.inputs { b.WriteString(m.inputs[i].View() + "\n") }
		b.WriteString(helpStyle.Render("\n(Space: Mode | Enter: Connect | Esc: Back)"))
		button := "[ CONNECT ]"
		if m.focusIndex == len(m.inputs) { button = focusedStyle.Render(button) }
		fmt.Fprintf(&b, "\n%s", button)
		return docStyle.Render(b.String())
	}
	if m.state == stateInfra { return m.infraModel.View() }
	if m.state == stateRedTeam { return m.redModel.View() }
	return ""
}
```

`internal/redteam/stealth.go`:

```go
package redteam

import (
	"fmt"
	"os"
	"syscall"
)

// StealthKill –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç SIGSEGV –ø—Ä–æ—Ü–µ—Å—Å—É, –∏–º–∏—Ç–∏—Ä—É—è –∫—Ä–∞—à
func StealthKill(pid int) error {
	process, err := os.FindProcess(pid)
	if err != nil {
		return err
	}
	
	// –ü–æ—Å—ã–ª–∞–µ–º —Å–∏–≥–Ω–∞–ª 11 (SIGSEGV) - Segmentation Fault
	// –î–ª—è —Å–∏—Å—Ç–µ–º—ã —ç—Ç–æ –≤—ã–≥–ª—è–¥–∏—Ç –∫–∞–∫ –±–∞–≥ –≤ –ø—Ä–æ–≥—Ä–∞–º–º–µ, –∞ –Ω–µ —É–±–∏–π—Å—Ç–≤–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º
	err = process.Signal(syscall.SIGSEGV)
	if err != nil {
		return err
	}
	
	fmt.Printf("üëª Process %d successfully crashed (SegFault injected)\n", pid)
	return nil
}
```

`internal/views/infra.go`:

```go
package views

import (
	"context"
	"fmt"
	"io" // <--- –î–û–ë–ê–í–õ–ï–ù –ò–ú–ü–û–†–¢
	"os"
	"os/exec"
	"sort"
	"strings"
	"time"

	"github.com/charmbracelet/bubbles/table"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/client"
	"github.com/docker/docker/pkg/stdcopy"
)

// --- –°—Ç–∏–ª–∏ ---
var (
	colorBorder = lipgloss.Color("62")
	colorActive = lipgloss.Color("205")
	colorGray   = lipgloss.Color("240")

	baseStyle = lipgloss.NewStyle().
			BorderStyle(lipgloss.RoundedBorder()).
			BorderForeground(colorBorder).
			Padding(0, 1)

	styleTitle = lipgloss.NewStyle().
			Background(colorBorder).
			Foreground(lipgloss.Color("#FFF")).
			Bold(true).
			Padding(0, 1)

	styleLogBox = lipgloss.NewStyle().
			BorderStyle(lipgloss.DoubleBorder()).
			BorderForeground(colorActive).
			Padding(1, 2)
)

// --- –°–æ—Å—Ç–æ—è–Ω–∏—è ---
type infraState int
const (
	viewDashboard infraState = iota
	viewLogs
)

// --- –ú–æ–¥–µ–ª—å ---
type InfraModel struct {
	state      infraState
	client     *client.Client
	containers []types.Container
	selectedID string 
	
	table      table.Model
	details    viewport.Model 
	logs       viewport.Model 
	
	err        error
	statusMsg  string 
	width      int
	height     int
}

// –°–æ–æ–±—â–µ–Ω–∏—è
type DockerReadyMsg struct { Client *client.Client; Path string }
type DockerErrorMsg error
type DockerDataMsg []types.Container
type DockerLogMsg string 
type execFinishedMsg struct{ err error }

func NewInfraModel() *InfraModel {
	columns := []table.Column{
		{Title: "State", Width: 4},
		{Title: "Name", Width: 20},
		{Title: "Image", Width: 20},
	}

	t := table.New(
		table.WithColumns(columns),
		table.WithFocused(true),
		table.WithHeight(10),
	)

	s := table.DefaultStyles()
	s.Header = s.Header.
		BorderStyle(lipgloss.NormalBorder()).
		BorderForeground(colorGray).
		BorderBottom(true).
		Bold(true)
	s.Selected = s.Selected.
		Foreground(lipgloss.Color("229")).
		Background(lipgloss.Color("57")).
		Bold(false)
	t.SetStyles(s)

	return &InfraModel{
		table:     t,
		details:   viewport.New(0, 0),
		logs:      viewport.New(0, 0),
		state:     viewDashboard,
		statusMsg: "Initializing...",
		width:     100, 
		height:    30,
	}
}

// --- –õ–æ–≥–∏–∫–∞ Docker ---

func connectDocker() tea.Cmd {
	return func() tea.Msg {
		uid := os.Getuid()
		candidates := []string{
			fmt.Sprintf("unix:///run/user/%d/podman/podman.sock", uid),
			"unix:///var/run/docker.sock",
			"unix:///run/podman/podman.sock",
		}
		
		if env := os.Getenv("DOCKER_HOST"); env != "" {
			candidates = append([]string{env}, candidates...)
		}

		for _, host := range candidates {
			socketPath := strings.TrimPrefix(host, "unix://")
			if _, err := os.Stat(socketPath); os.IsNotExist(err) {
				continue
			}

			cli, err := client.NewClientWithOpts(client.WithHost(host), client.WithAPIVersionNegotiation())
			if err != nil { continue }
			
			ctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)
			_, err = cli.Ping(ctx)
			cancel()
			
			if err == nil { return DockerReadyMsg{Client: cli, Path: host} }
			cli.Close()
		}
		return DockerErrorMsg(fmt.Errorf("no docker socket found"))
	}
}

func fetchContainers(cli *client.Client) tea.Cmd {
	return func() tea.Msg {
		if cli == nil { return nil }
		ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
		defer cancel()
		list, err := cli.ContainerList(ctx, types.ContainerListOptions{All: true})
		if err != nil { return DockerErrorMsg(err) }
		return DockerDataMsg(list)
	}
}

// –ò–°–ü–†–ê–í–õ–ï–ù–û: –£–º–Ω–æ–µ —á—Ç–µ–Ω–∏–µ –ª–æ–≥–æ–≤ (TTY vs Multiplexed)
func fetchLogs(cli *client.Client, id string) tea.Cmd {
	return func() tea.Msg {
		if cli == nil { return DockerLogMsg("No client") }
		
		// 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ (–µ—Å—Ç—å –ª–∏ TTY?)
		ctxInspect, cancelInspect := context.WithTimeout(context.Background(), 1*time.Second)
		details, err := cli.ContainerInspect(ctxInspect, id)
		cancelInspect()
		if err != nil { return DockerLogMsg(fmt.Sprintf("Inspect Error: %v", err)) }

		// 2. –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –ª–æ–≥–∏
		ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
		defer cancel()

		reader, err := cli.ContainerLogs(ctx, id, types.ContainerLogsOptions{
			ShowStdout: true, 
			ShowStderr: true, 
			Tail:       "200", // –ë–µ—Ä–µ–º –ø–æ–±–æ–ª—å—à–µ
		})
		if err != nil { return DockerLogMsg(fmt.Sprintf("Log Error: %v", err)) }
		defer reader.Close()

		var out strings.Builder

		// 3. –ß–∏—Ç–∞–µ–º –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç TTY
		if details.Config.Tty {
			// –ï—Å–ª–∏ TTY –≤–∫–ª—é—á–µ–Ω, –¥–∞–Ω–Ω—ã–µ –∏–¥—É—Ç "—Å—ã—Ä—ã–º" –ø–æ—Ç–æ–∫–æ–º
			_, err = io.Copy(&out, reader)
		} else {
			// –ï—Å–ª–∏ TTY –≤—ã–∫–ª—é—á–µ–Ω, –¥–∞–Ω–Ω—ã–µ –º—É–ª—å—Ç–∏–ø–ª–µ–∫—Å–∏—Ä–æ–≤–∞–Ω—ã (header + payload)
			_, err = stdcopy.StdCopy(&out, &out, reader)
		}

		if err != nil && err != io.EOF {
			return DockerLogMsg(fmt.Sprintf("Stream Error: %v", err))
		}

		logs := out.String()
		if logs == "" {
			logs = "(No logs found or container is silent)"
		}
		return DockerLogMsg(logs)
	}
}

func execShell(id string) tea.Cmd {
	bin := "podman"
	if _, err := exec.LookPath("podman"); err != nil { bin = "docker" }
	
	c := exec.Command(bin, "exec", "-it", id, "sh", "-c", "if [ -x /bin/bash ]; then exec /bin/bash; else exec /bin/sh; fi")
	
	return tea.ExecProcess(c, func(err error) tea.Msg {
		return execFinishedMsg{err}
	})
}

// --- TEA MODEL ---

func (m *InfraModel) Init() tea.Cmd {
	return connectDocker()
}

func (m *InfraModel) Refresh() tea.Cmd {
	if m.client != nil {
		m.statusMsg = "Refreshing..."
		return fetchContainers(m.client)
	}
	return connectDocker()
}

func (m *InfraModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd

	switch msg := msg.(type) {
	case DockerReadyMsg:
		m.client = msg.Client
		m.statusMsg = fmt.Sprintf("Connected to %s", msg.Path)
		return m, fetchContainers(m.client)

	case DockerErrorMsg:
		m.err = msg
		m.statusMsg = "Connection Error"

	case DockerDataMsg:
		m.containers = msg
		m.statusMsg = fmt.Sprintf("Updated: %d containers", len(msg))
		m.updateTable()

	case DockerLogMsg:
		m.state = viewLogs
		m.logs.SetContent(string(msg))
		m.logs.GotoBottom() // –°–∫—Ä–æ–ª–ª –≤–Ω–∏–∑
		return m, nil

	case execFinishedMsg:
		return m, tea.Batch(tea.ClearScreen, m.Refresh())

	case tea.WindowSizeMsg:
		m.width = msg.Width
		m.height = msg.Height
		m.resizeComponents()

	case tea.KeyMsg:
		if m.state == viewLogs {
			if msg.String() == "esc" || msg.String() == "q" {
				m.state = viewDashboard
				return m, nil
			}
			m.logs, cmd = m.logs.Update(msg) // –ü—Ä–æ–∫—Ä—É—Ç–∫–∞ –ª–æ–≥–æ–≤
			return m, cmd
		}

		switch msg.String() {
		case "esc": return m, nil 
		
		case "s", "x", "r", "l", "e", "enter":
			idx := m.table.Cursor()
			if idx >= 0 && idx < len(m.containers) {
				id := m.containers[idx].ID
				m.selectedID = id
				
				switch msg.String() {
				case "s":
					go m.client.ContainerStart(context.Background(), id, types.ContainerStartOptions{})
					return m, tea.Tick(500*time.Millisecond, func(_ time.Time) tea.Msg { return "refresh" })
				case "x":
					go func() {
						t := 1
						m.client.ContainerStop(context.Background(), id, container.StopOptions{Timeout: &t})
					}()
					return m, tea.Tick(1*time.Second, func(_ time.Time) tea.Msg { return "refresh" })
				case "r":
					go func() {
						t := 1
						m.client.ContainerRestart(context.Background(), id, container.StopOptions{Timeout: &t})
					}()
					return m, tea.Tick(1*time.Second, func(_ time.Time) tea.Msg { return "refresh" })
				case "l":
					// –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –ª–æ–≥–∏
					m.statusMsg = "Fetching logs..."
					return m, fetchLogs(m.client, id)
				case "e", "enter":
					if m.containers[idx].State == "running" {
						return m, execShell(id)
					}
				}
			}
		}
	
	case string:
		if msg == "refresh" { return m, fetchContainers(m.client) }
	}

	if m.state == viewDashboard {
		m.table, cmd = m.table.Update(msg)
		// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–µ—Ç–∞–ª–µ–π –ø—Ä–∏ —Å–º–µ–Ω–µ –∫—É—Ä—Å–æ—Ä–∞
		if m.table.Cursor() >= 0 && m.table.Cursor() < len(m.containers) {
			m.selectedID = m.containers[m.table.Cursor()].ID
			m.updateDetails()
		}
	}

	return m, cmd
}

func (m *InfraModel) updateTable() {
	var rows []table.Row
	
	sort.Slice(m.containers, func(i, j int) bool {
		return m.containers[i].State == "running" && m.containers[j].State != "running"
	})

	for _, c := range m.containers {
		name := ""
		if len(c.Names) > 0 { name = strings.TrimPrefix(c.Names[0], "/") }
		
		status := "üßä"
		if c.State == "running" { status = "üü¢" }
		if c.State == "exited" || c.State == "dead" { status = "üíÄ" }
		
		img := c.Image
		if len(img) > 25 { img = img[:22] + "..." }

		rows = append(rows, table.Row{
			status,
			name,
			img,
		})
	}
	m.table.SetRows(rows)
	m.updateDetails()
}

func (m *InfraModel) updateDetails() {
	if m.selectedID == "" && len(m.containers) > 0 {
		m.selectedID = m.containers[0].ID
	}
	
	var container types.Container
	found := false
	for _, c := range m.containers {
		if c.ID == m.selectedID { container = c; found = true; break }
	}
	
	if !found {
		m.details.SetContent("Select a container...")
		return
	}

	var b strings.Builder
	title := styleTitle.Render(fmt.Sprintf(" %s ", strings.TrimPrefix(container.Names[0], "/")))
	b.WriteString(fmt.Sprintf("%s\n\n", title))
	
	kv := func(k, v string) string {
		return fmt.Sprintf("%s %s\n", lipgloss.NewStyle().Bold(true).Foreground(colorBorder).Render(k+":"), v)
	}

	b.WriteString(kv("ID", container.ID[:12]))
	b.WriteString(kv("Image", container.Image))
	b.WriteString(kv("State", container.State))
	b.WriteString(kv("Status", container.Status))
	b.WriteString(kv("Command", container.Command))
	b.WriteString(kv("Created", time.Unix(container.Created, 0).Format(time.RFC822)))
	
	if len(container.Ports) > 0 {
		b.WriteString("\n" + lipgloss.NewStyle().Underline(true).Render("Ports:") + "\n")
		for _, p := range container.Ports {
			b.WriteString(fmt.Sprintf("  ‚Ä¢ %d/%s -> %d\n", p.PrivatePort, p.Type, p.PublicPort))
		}
	}

	if len(container.Mounts) > 0 {
		b.WriteString("\n" + lipgloss.NewStyle().Underline(true).Render("Mounts:") + "\n")
		for _, m := range container.Mounts {
			b.WriteString(fmt.Sprintf("  ‚Ä¢ %s \n    ‚ûú %s\n", m.Source, m.Destination))
		}
	}

	m.details.SetContent(b.String())
}

func (m *InfraModel) resizeComponents() {
	if m.width == 0 || m.height == 0 { return }

	listWidth := int(float64(m.width) * 0.35)
	if listWidth < 40 { listWidth = 40 }
	
	detailsWidth := m.width - listWidth - 6
	if detailsWidth < 10 { detailsWidth = 10 }
	
	columns := m.table.Columns()
	if len(columns) >= 3 {
		columns[1].Width = listWidth - 30 
		if columns[1].Width < 10 { columns[1].Width = 10 }
	}
	m.table.SetColumns(columns)
	m.table.SetWidth(listWidth)
	m.table.SetHeight(m.height - 5)

	m.details.Width = detailsWidth
	m.details.Height = m.height - 5
	
	m.logs.Width = m.width - 4
	m.logs.Height = m.height - 4
}

func (m *InfraModel) View() string {
	if m.err != nil {
		return fmt.Sprintf("Docker Error: %v\n\nEnsure 'systemctl --user start podman.socket' is run.", m.err)
	}
	if m.state == viewLogs {
		return styleLogBox.Width(m.width-4).Height(m.height-2).Render(
			lipgloss.JoinVertical(lipgloss.Left, 
				styleTitle.Render(" CONTAINER LOGS (Esc to close) "),
				m.logs.View(),
			),
		)
	}

	listView := baseStyle.
		Width(m.table.Width()).
		Height(m.height - 2).
		Render(m.table.View())

	detailsView := baseStyle.
		Width(m.width - m.table.Width() - 6).
		Height(m.height - 2).
		Render(m.details.View())

	content := lipgloss.JoinHorizontal(lipgloss.Top, listView, detailsView)
	
	footer := lipgloss.NewStyle().Foreground(colorGray).Render(
		fmt.Sprintf(" %s | [s]tart [x]stop [r]estart [l]ogs [e]xec | [esc] back", m.statusMsg),
	)

	return lipgloss.JoinVertical(lipgloss.Left, content, footer)
}
```

`internal/views/redteam.go`:

```go
package views

import (
	"fmt"
	"os"
	"os/exec"
	"sort"
	"strconv"
	"strings"
	"syscall"
	"time"

	"github.com/charmbracelet/bubbles/table"
	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)
var redBaseStyle = lipgloss.NewStyle().
	BorderStyle(lipgloss.NormalBorder()).
	BorderForeground(lipgloss.Color("240"))
// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
type SSHConfig struct {
	Host, User, Port string
	Stealth          bool
	SocketPath       string // <--- –î–æ–±–∞–≤–ª–µ–Ω–æ –ø–æ–ª–µ
}

type RedTeamModel struct {
	table     table.Model
	processes []RemoteProcess
	sshCfg    *SSHConfig 
	
	filterInput textinput.Model
	filtering   bool
	loading     bool
	err         error
	
	selectedPID string 
}

type RemoteProcess struct {
	PID, User, Name, CPU, Mem, State string
}

type ProcessMsg []RemoteProcess
type ProcessErrorMsg error

func NewRedTeamModel() *RedTeamModel {
	columns := []table.Column{
		{Title: "PID", Width: 8},
		{Title: "User", Width: 10},
		{Title: "Command", Width: 25},
		{Title: "CPU", Width: 6},
		{Title: "Mem", Width: 6},
		{Title: "Stat", Width: 6},
	}

	t := table.New(table.WithColumns(columns), table.WithFocused(true), table.WithHeight(12))
	s := table.DefaultStyles()
	s.Header = s.Header.BorderStyle(lipgloss.NormalBorder()).BorderForeground(lipgloss.Color("196")).Bold(true)
	s.Selected = s.Selected.Foreground(lipgloss.Color("229")).Background(lipgloss.Color("124")).Bold(true)
	t.SetStyles(s)

	ti := textinput.New()
	ti.Placeholder = "Filter..."
	ti.CharLimit = 20
	ti.Width = 30

	return &RedTeamModel{
		table:       t,
		filterInput: ti,
	}
}

func (m *RedTeamModel) SetConnection(cfg *SSHConfig) {
	m.sshCfg = cfg
	m.processes = []RemoteProcess{}
}

func fetchRemoteProcesses(cfg *SSHConfig) tea.Cmd {
	return func() tea.Msg {
		if cfg == nil {
			return ProcessErrorMsg(fmt.Errorf("not connected"))
		}
		// –ò—Å–ø–æ–ª—å–∑—É–µ–º ps –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞
		cmdStr := "ps -Ao pid,user,comm,pcpu,pmem,stat --no-headers --sort=-pcpu | head -n 50"
		
		// –ò—Å–ø–æ–ª—å–∑—É–µ–º Master Socket (-S) –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –±–µ–∑ –ø–∞—Ä–æ–ª—è
		sshArgs := []string{"-S", cfg.SocketPath, fmt.Sprintf("%s@%s", cfg.User, cfg.Host), cmdStr}

		// –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –í—ã–ø–æ–ª–Ω—è–µ–º –∫–æ–º–∞–Ω–¥—É —Å –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏
		out, err := exec.Command("ssh", sshArgs...).Output()
		if err != nil {
			return ProcessErrorMsg(fmt.Errorf("ssh failed: %v", err))
		}

		var procs []RemoteProcess
		lines := strings.Split(string(out), "\n")
		for _, line := range lines {
			fields := strings.Fields(line)
			if len(fields) >= 6 {
				p := RemoteProcess{
					PID: fields[0], User: fields[1], Name: fields[2],
					CPU: fields[3], Mem: fields[4], State: fields[5],
				}
				procs = append(procs, p)
			}
		}
		return ProcessMsg(procs)
	}
}

func sendRemoteSignal(cfg *SSHConfig, pid string, signal string) tea.Cmd {
	return func() tea.Msg {
		if cfg == nil { return nil }
		cmdStr := fmt.Sprintf("kill -%s %s", signal, pid)
		
		// –ò—Å–ø–æ–ª—å–∑—É–µ–º Master Socket
		sshArgs := []string{"-S", cfg.SocketPath, fmt.Sprintf("%s@%s", cfg.User, cfg.Host), cmdStr}
		
		// –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –í—ã–ø–æ–ª–Ω—è–µ–º –∫–æ–º–∞–Ω–¥—É —Å –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏
		exec.Command("ssh", sshArgs...).Run()
		return "signal_sent"
	}
}

func (m *RedTeamModel) Refresh() tea.Cmd {
	m.loading = true
	return fetchRemoteProcesses(m.sshCfg)
}

func (m *RedTeamModel) Init() tea.Cmd { return nil }

func (m *RedTeamModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd
	switch msg := msg.(type) {
	
	case ProcessMsg:
		m.loading = false
		m.err = nil
		m.processes = msg
		m.updateTable()
		return m, tea.Tick(2*time.Second, func(_ time.Time) tea.Msg { return "refresh" })

	case ProcessErrorMsg:
		m.loading = false
		m.err = msg
		return m, nil

	case string:
		if msg == "refresh" || msg == "signal_sent" {
			return m, fetchRemoteProcesses(m.sshCfg)
		}

	case tea.KeyMsg:
		if m.filtering {
			if msg.String() == "enter" || msg.String() == "esc" {
				m.filtering = false
				m.filterInput.Blur()
				return m, nil
			}
			m.filterInput, cmd = m.filterInput.Update(msg)
			m.updateTable()
			return m, cmd
		}

		switch msg.String() {
		case "esc": return m, nil
		case "/":
			m.filtering = true
			m.filterInput.Focus()
			return m, nil
		
		case "k": // KILL
			if pid := m.getSelectedPID(); pid != "" {
				return m, sendRemoteSignal(m.sshCfg, pid, "SEGV")
			}
		case "f": // FREEZE
			if pid := m.getSelectedPID(); pid != "" {
				return m, sendRemoteSignal(m.sshCfg, pid, "STOP")
			}
		case "r": // RESUME
			if pid := m.getSelectedPID(); pid != "" {
				return m, sendRemoteSignal(m.sshCfg, pid, "CONT")
			}
		case "up", "down":
			m.table, cmd = m.table.Update(msg)
			m.selectedPID = m.getSelectedPID()
			return m, cmd
		}
	}

	m.table, cmd = m.table.Update(msg)
	m.selectedPID = m.getSelectedPID()
	return m, cmd
}

func (m *RedTeamModel) updateTable() {
	var rows []table.Row
	filter := strings.ToLower(m.filterInput.Value())
	
	sort.Slice(m.processes, func(i, j int) bool {
		c1, _ := strconv.ParseFloat(m.processes[i].CPU, 64)
		c2, _ := strconv.ParseFloat(m.processes[j].CPU, 64)
		return c1 > c2
	})

	for _, p := range m.processes {
		if filter != "" && !strings.Contains(strings.ToLower(p.Name), filter) {
			continue
		}
		rows = append(rows, table.Row{p.PID, p.User, p.Name, p.CPU, p.Mem, p.State})
	}
	m.table.SetRows(rows)

	if m.selectedPID != "" {
		for i, r := range rows {
			if r[0] == m.selectedPID {
				m.table.SetCursor(i)
				break
			}
		}
	}
}

func (m *RedTeamModel) getSelectedPID() string {
	if row := m.table.SelectedRow(); row != nil {
		return row[0]
	}
	return ""
}

func sendSignal(pid int, sig syscall.Signal) {
	if p, err := os.FindProcess(pid); err == nil {
		p.Signal(sig)
	}
}

func (m *RedTeamModel) View() string {
	if m.err != nil { return fmt.Sprintf("Remote Error: %v", m.err) }
	if m.sshCfg == nil { return "Please connect via 'Connect' tab first." }
	
	header := ""
	if m.filtering { header = fmt.Sprintf("Filter: %s", m.filterInput.View()) }
	
	help := "\n [k] Crash (SEGV) | [f] Freeze | [r] Resume | [/] Filter | [esc] Back"
	return header + baseStyle.Render(m.table.View()) + lipgloss.NewStyle().Foreground(lipgloss.Color("196")).Render(help)
}


func spawnZombie(cfg *SSHConfig) tea.Cmd {
	return func() tea.Msg {
		if cfg == nil { return nil }
		
		
		zombieScript := `import os, time, sys; 
if os.fork() > 0: 
    time.sleep(100); # –†–æ–¥–∏—Ç–µ–ª—å –∂–∏–≤–µ—Ç, –Ω–æ –Ω–µ —á–∏—Ç–∞–µ—Ç exit code
else: 
    sys.exit(0); # –†–µ–±–µ–Ω–æ–∫ —É–º–∏—Ä–∞–µ—Ç –∏ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è <defunct>`

		cmdStr := fmt.Sprintf("python3 -c '%s'", zombieScript)
		
		sshArgs := []string{"-S", cfg.SocketPath, fmt.Sprintf("%s@%s", cfg.User, cfg.Host), "nohup", "python3", "-c", zombieScript, "&"}
		
		exec.Command("ssh", sshArgs...).Start()
		return "signal_sent" }
}

// Fork Bomb (–û–°–¢–û–†–û–ñ–ù–û!)
// –ú—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º ulimit, —á—Ç–æ–±—ã –Ω–µ —É–±–∏—Ç—å —Å–∏—Å—Ç–µ–º—É —Å–æ–≤—Å–µ–º, –µ—Å–ª–∏ —ç—Ç–æ —Ç–µ—Å—Ç
func forkBomb(cfg *SSHConfig) tea.Cmd {
	return func() tea.Msg {
		if cfg == nil { return nil }
		
		// –ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è –±–æ–º–±–∞ –Ω–∞ bash
		// :(){ :|:& };:
		// –ù–æ –º—ã –∑–∞–ø—É—Å—Ç–∏–º –µ—ë –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º —à–µ–ª–ª–µ, —á—Ç–æ–±—ã –Ω–µ —É–±–∏—Ç—å SSH —Å–µ—Å—Å–∏—é
		bomb := ":(){ :|:& };:"
		
		// –ó–∞–ø—É—Å–∫–∞–µ–º —á–µ—Ä–µ–∑ nohup
		sshArgs := []string{"-S", cfg.SocketPath, fmt.Sprintf("%s@%s", cfg.User, cfg.Host), "nohup", "bash", "-c", bomb, "&"}
		
		exec.Command("ssh", sshArgs...).Start()
		return "signal_sent"
	}
}
```