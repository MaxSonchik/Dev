Project Path: d-env

Source Tree:

```txt
d-env
‚îú‚îÄ‚îÄ cmd
‚îÇ   ‚îî‚îÄ‚îÄ d-env
‚îÇ       ‚îî‚îÄ‚îÄ main.go
‚îú‚îÄ‚îÄ go.mod
‚îú‚îÄ‚îÄ go.sum
‚îî‚îÄ‚îÄ internal
    ‚îú‚îÄ‚îÄ analyzer
    ‚îÇ   ‚îî‚îÄ‚îÄ detect.go
    ‚îú‚îÄ‚îÄ git
    ‚îÇ   ‚îî‚îÄ‚îÄ client.go
    ‚îú‚îÄ‚îÄ modules
    ‚îÇ   ‚îú‚îÄ‚îÄ docker
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ docker.go
    ‚îÇ   ‚îú‚îÄ‚îÄ general
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.go
    ‚îÇ   ‚îú‚îÄ‚îÄ git
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ git.go
    ‚îÇ   ‚îî‚îÄ‚îÄ infra
    ‚îÇ       ‚îî‚îÄ‚îÄ infra.go
    ‚îî‚îÄ‚îÄ ui
        ‚îî‚îÄ‚îÄ model.go

```

`cmd/d-env/main.go`:

```go
package main

import (
	"fmt"
	"os"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/devos-os/d-env/internal/ui"
)

func main() {
	cwd, err := os.Getwd()
	if err != nil {
		fmt.Println("Error getting current directory:", err)
		os.Exit(1)
	}

	p := tea.NewProgram(ui.InitialModel(cwd))
	if _, err := p.Run(); err != nil {
		fmt.Printf("Alas, there's been an error: %v", err)
		os.Exit(1)
	}
}
```

`go.mod`:

```mod
module github.com/devos-os/d-env

go 1.25.4

require (
	github.com/charmbracelet/bubbles v0.21.0
	github.com/charmbracelet/bubbletea v1.3.10
	github.com/charmbracelet/lipgloss v1.1.0
)

require (
	github.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect
	github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc // indirect
	github.com/charmbracelet/x/ansi v0.10.1 // indirect
	github.com/charmbracelet/x/cellbuf v0.0.13-0.20250311204145-2c3ea96c31dd // indirect
	github.com/charmbracelet/x/term v0.2.1 // indirect
	github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f // indirect
	github.com/lucasb-eyer/go-colorful v1.2.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mattn/go-localereader v0.0.1 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect
	github.com/muesli/cancelreader v0.2.2 // indirect
	github.com/muesli/termenv v0.16.0 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e // indirect
	golang.org/x/sys v0.36.0 // indirect
	golang.org/x/text v0.3.8 // indirect
)

```

`go.sum`:

```sum
github.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=
github.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=
github.com/charmbracelet/bubbles v0.21.0 h1:9TdC97SdRVg/1aaXNVWfFH3nnLAwOXr8Fn6u6mfQdFs=
github.com/charmbracelet/bubbles v0.21.0/go.mod h1:HF+v6QUR4HkEpz62dx7ym2xc71/KBHg+zKwJtMw+qtg=
github.com/charmbracelet/bubbletea v1.3.10 h1:otUDHWMMzQSB0Pkc87rm691KZ3SWa4KUlvF9nRvCICw=
github.com/charmbracelet/bubbletea v1.3.10/go.mod h1:ORQfo0fk8U+po9VaNvnV95UPWA1BitP1E0N6xJPlHr4=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc h1:4pZI35227imm7yK2bGPcfpFEmuY1gc2YSTShr4iJBfs=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc/go.mod h1:X4/0JoqgTIPSFcRA/P6INZzIuyqdFY5rm8tb41s9okk=
github.com/charmbracelet/lipgloss v1.1.0 h1:vYXsiLHVkK7fp74RkV7b2kq9+zDLoEU4MZoFqR/noCY=
github.com/charmbracelet/lipgloss v1.1.0/go.mod h1:/6Q8FR2o+kj8rz4Dq0zQc3vYf7X+B0binUUBwA0aL30=
github.com/charmbracelet/x/ansi v0.10.1 h1:rL3Koar5XvX0pHGfovN03f5cxLbCF2YvLeyz7D2jVDQ=
github.com/charmbracelet/x/ansi v0.10.1/go.mod h1:3RQDQ6lDnROptfpWuUVIUG64bD2g2BgntdxH0Ya5TeE=
github.com/charmbracelet/x/cellbuf v0.0.13-0.20250311204145-2c3ea96c31dd h1:vy0GVL4jeHEwG5YOXDmi86oYw2yuYUGqz6a8sLwg0X8=
github.com/charmbracelet/x/cellbuf v0.0.13-0.20250311204145-2c3ea96c31dd/go.mod h1:xe0nKWGd3eJgtqZRaN9RjMtK7xUYchjzPr7q6kcvCCs=
github.com/charmbracelet/x/term v0.2.1 h1:AQeHeLZ1OqSXhrAWpYUtZyX1T3zVxfpZuEQMIQaGIAQ=
github.com/charmbracelet/x/term v0.2.1/go.mod h1:oQ4enTYFV7QN4m0i9mzHrViD7TQKvNEEkHUMCmsxdUg=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f h1:Y/CXytFA4m6baUTXGLOoWe4PQhGxaX0KpnayAqC48p4=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f/go.mod h1:vw97MGsxSvLiUE2X8qFplwetxpGLQrlU1Q9AUEIzCaM=
github.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=
github.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mattn/go-localereader v0.0.1 h1:ygSAOl7ZXTx4RdPYinUpg6W99U8jWvWi9Ye2JC/oIi4=
github.com/mattn/go-localereader v0.0.1/go.mod h1:8fBrzywKY7BI3czFoHkuzRoWE9C+EiG4R1k4Cjx5p88=
github.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=
github.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 h1:ZK8zHtRHOkbHy6Mmr5D264iyp3TiX5OmNcI5cIARiQI=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6/go.mod h1:CJlz5H+gyd6CUWT45Oy4q24RdLyn7Md9Vj2/ldJBSIo=
github.com/muesli/cancelreader v0.2.2 h1:3I4Kt4BQjOR54NavqnDogx/MIoWBFa0StPA8ELUXHmA=
github.com/muesli/cancelreader v0.2.2/go.mod h1:3XuTXfFS2VjM+HTLZY9Ak0l6eUKfijIfMUZ4EgX0QYo=
github.com/muesli/termenv v0.16.0 h1:S5AlUN9dENB57rsbnkPyfdGuWIlkmzJjbFf0Tf5FWUc=
github.com/muesli/termenv v0.16.0/go.mod h1:ZRfOIKPFDYQoDFF4Olj7/QJbW60Ol/kL1pU3VfY/Cnk=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=
github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e h1:JVG44RsyaB9T2KIHavMF/ppJZNG9ZpyihvCd0w101no=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e/go.mod h1:RbqR21r5mrJuqunuUZ/Dhy/avygyECGrLceyNeo4LiM=
golang.org/x/exp v0.0.0-20220909182711-5c715a9e8561 h1:MDc5xs78ZrZr3HMQugiXOAkSZtfTpbJLDr/lwfgO53E=
golang.org/x/exp v0.0.0-20220909182711-5c715a9e8561/go.mod h1:cyybsKvd6eL0RnXn6p/Grxp8F5bW7iYuBgsNCOHpMYE=
golang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.36.0 h1:KVRy2GtZBrk1cBYA7MKu5bEZFxQk4NIDV6RLVcC8o0k=
golang.org/x/sys v0.36.0/go.mod h1:OgkHotnGiDImocRcuBABYBEXf8A9a87e/uXjp9XT3ks=
golang.org/x/text v0.3.8 h1:nAL+RVCQ9uMn3vJZbV+MRnydTJFPf8qqY42YiA6MrqY=
golang.org/x/text v0.3.8/go.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=

```

`internal/analyzer/detect.go`:

```go
package analyzer

import (
	"github.com/devos-os/d-env/internal/modules/docker"
	"github.com/devos-os/d-env/internal/modules/general"
	"github.com/devos-os/d-env/internal/modules/git"
	"github.com/devos-os/d-env/internal/modules/infra"
)

type Report struct {
	General general.GeneralData
	Git     git.GitData
	Docker  docker.DockerData
	Infra   infra.InfraData
}

func Analyze(root string) Report {
	return Report{
		General: general.Analyze(root),
		Git:     git.Analyze(root),
		Docker:  docker.Analyze(root),
		Infra:   infra.Analyze(root),
	}
}
```

`internal/git/client.go`:

```go
package git

import (
	"os/exec"
	"strings"
)

type GitInfo struct {
	Branch      string
	Hash        string
	Message     string
	Author      string
	IsDirty     bool
	Initialized bool
}

func GetInfo() GitInfo {
	info := GitInfo{Initialized: false}

	// –ü—Ä–æ–≤–µ—Ä–∫–∞, –µ—Å—Ç—å –ª–∏ git
	if _, err := exec.Command("git", "rev-parse", "--is-inside-work-tree").Output(); err != nil {
		return info
	}
	info.Initialized = true

	// –í–µ—Ç–∫–∞
	out, _ := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD").Output()
	info.Branch = strings.TrimSpace(string(out))

	// –•—ç—à –∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∫–æ–º–º–∏—Ç–∞
	out, _ = exec.Command("git", "log", "-1", "--format=%h|%s|%an").Output()
	parts := strings.Split(strings.TrimSpace(string(out)), "|")
	if len(parts) >= 3 {
		info.Hash = parts[0]
		info.Message = parts[1]
		info.Author = parts[2]
	}

	// –°—Ç–∞—Ç—É—Å (Dirty check)
	out, _ = exec.Command("git", "status", "--porcelain").Output()
	if len(strings.TrimSpace(string(out))) > 0 {
		info.IsDirty = true
	}

	return info
}
```

`internal/modules/docker/docker.go`:

```go
package docker

import (
	"bufio"
	"os"
	"path/filepath"
	"strconv" // <--- –î–û–ë–ê–í–õ–ï–ù –ò–ú–ü–û–†–¢
	"strings"
)

type DockerData struct {
	Found       bool
	Stages      []BuildStage
	ComposeSvcs []string
	Compose     []ComposeService
}

type BuildStage struct {
	Name  string
	Base  string
	Steps []string
}

type ComposeService struct {
	Name      string
	Image     string
	DependsOn []string
}

func Analyze(root string) DockerData {
	d := DockerData{}
	
	// Dockerfile Analysis
	path := filepath.Join(root, "Dockerfile")
	if file, err := os.Open(path); err == nil {
		d.Found = true
		scanner := bufio.NewScanner(file)
		var current *BuildStage
		stageCount := 0
		
		for scanner.Scan() {
			line := strings.TrimSpace(scanner.Text())
			if strings.HasPrefix(line, "FROM") {
				stageCount++
				parts := strings.Fields(line)
				if len(parts) < 2 { continue }
				
				base := parts[1]
				
				// –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –ó–î–ï–°–¨: –∏—Å–ø–æ–ª—å–∑—É–µ–º strconv.Itoa –≤–º–µ—Å—Ç–æ string()
				name := "Stage " + strconv.Itoa(stageCount)
				
				if len(parts) >= 4 && strings.ToLower(parts[2]) == "as" {
					name = parts[3]
				}
				d.Stages = append(d.Stages, BuildStage{Name: name, Base: base, Steps: []string{}})
				current = &d.Stages[len(d.Stages)-1]
			} else if current != nil && (strings.HasPrefix(line, "RUN") || strings.HasPrefix(line, "COPY")) {
				current.Steps = append(current.Steps, line)
			}
		}
		file.Close()
	}

	// Docker Compose Analysis
	dcPath := filepath.Join(root, "docker-compose.yml")
	if file, err := os.Open(dcPath); err == nil {
		d.Found = true
		scanner := bufio.NewScanner(file)
		var currentSvc *ComposeService
		indent := 0
		
		for scanner.Scan() {
			rawLine := scanner.Text()
			line := strings.TrimSpace(rawLine)
			if line == "" || strings.HasPrefix(line, "#") { continue }
			
			currIndent := len(rawLine) - len(strings.TrimLeft(rawLine, " "))
			
			// Detect service
			if currIndent == 2 && strings.HasSuffix(line, ":") && !strings.HasPrefix(line, "version") && !strings.HasPrefix(line, "services") {
				name := strings.TrimSuffix(line, ":")
				d.Compose = append(d.Compose, ComposeService{Name: name})
				currentSvc = &d.Compose[len(d.Compose)-1]
				indent = 2
				continue
			}

			if currentSvc != nil && currIndent > indent {
				if strings.HasPrefix(line, "image:") {
					currentSvc.Image = strings.TrimPrefix(line, "image: ")
				}
				// –ü—Ä–æ—Å—Ç–æ–π –ø–∞—Ä—Å–∏–Ω–≥ depends_on
				if strings.TrimSpace(line) == "depends_on:" {
					// –í —Å–ª–µ–¥—É—é—â–∏—Ö —Å—Ç—Ä–æ–∫–∞—Ö –±—É–¥–µ–º –∏—Å–∫–∞—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ (—É–ø—Ä–æ—â–µ–Ω–Ω–æ)
				}
				if strings.HasPrefix(line, "- ") && currIndent > indent+2 {
					// –≠—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å —ç–ª–µ–º–µ–Ω—Ç —Å–ø–∏—Å–∫–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, depends_on)
					// –î–ª—è MVP —Å–ª–æ–∂–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥ YAML –≤—Ä—É—á–Ω—É—é –æ–ø—É—Å—Ç–∏–º, –ø–æ–ª–∞–≥–∞—è—Å—å –Ω–∞ —Ä–µ–≥—É–ª—è—Ä–∫–∏ –≤ –¥—Ä—É–≥–∏—Ö –º–æ–¥—É–ª—è—Ö
				}
			}
		}
		file.Close()
	}

	return d
}
```

`internal/modules/general/main.go`:

```go
package general

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

type GeneralData struct {
	Stacks      []Stack
	HealthScore int
	Risks       []string
	Tree        string
}

type Stack struct { Name, Version, Color string }

func Analyze(root string) GeneralData {
	g := GeneralData{HealthScore: 100}
	
	// 1. Scan Stacks & Risks
	filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil { return nil }
		if info.IsDir() && (info.Name() == ".git" || info.Name() == "node_modules") { return filepath.SkipDir }
		
		// Stacks
		if info.Name() == "go.mod" { g.Stacks = append(g.Stacks, Stack{"Go", "1.x", "#00ADD8"}) }
		if info.Name() == "package.json" { g.Stacks = append(g.Stacks, Stack{"Node.js", "?", "#87D75F"}) }
		if info.Name() == "requirements.txt" { g.Stacks = append(g.Stacks, Stack{"Python", "Pip", "#3776AB"}) }
		if info.Name() == "Cargo.toml" { g.Stacks = append(g.Stacks, Stack{"Rust", "Cargo", "#DEA584"}) }

		// Risks
		if info.Name() == ".env" {
			g.HealthScore -= 20
			// Check if ignored
			gitignore, _ := os.ReadFile(filepath.Join(root, ".gitignore"))
			if !strings.Contains(string(gitignore), ".env") {
				g.HealthScore -= 30
				g.Risks = append(g.Risks, "CRITICAL: .env file exists and is NOT ignored in git!")
			} else {
				g.Risks = append(g.Risks, "Warning: .env file found (local config)")
			}
		}
		return nil
	})

	if len(g.Stacks) == 0 {
		g.HealthScore -= 10
		g.Risks = append(g.Risks, "No standard project configuration found")
	}

	// 2. Generate Tree
	g.Tree = generateTree(root, "", true, 0)
	
	return g
}

func generateTree(path string, prefix string, isRoot bool, depth int) string {
	if depth > 3 { return "" } // Limit depth
	var sb strings.Builder
	files, _ := os.ReadDir(path)
	
	filtered := []os.DirEntry{}
	for _, f := range files {
		if f.Name() != ".git" && f.Name() != "node_modules" { filtered = append(filtered, f) }
	}

	for i, f := range filtered {
		isLast := i == len(filtered)-1
		pointer := "‚îú‚îÄ‚îÄ"
		if isLast { pointer = "‚îî‚îÄ‚îÄ" }
		
		icon := "üìÑ"
		if f.IsDir() { icon = "üìÇ" }
		
		sb.WriteString(fmt.Sprintf("%s%s %s %s\n", prefix, pointer, icon, f.Name()))

		if f.IsDir() {
			newPrefix := prefix + "‚îÇ   "
			if isLast { newPrefix = prefix + "    " }
			sb.WriteString(generateTree(filepath.Join(path, f.Name()), newPrefix, false, depth+1))
		}
	}
	return sb.String()
}
```

`internal/modules/git/git.go`:

```go
package git

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
)

type GitData struct {
	IsRepo      bool
	Branch      string
	Hash        string
	StatusItems []string
	Graph       string
}

func Analyze(root string) GitData {
	g := GitData{}
	if _, err := os.Stat(root + "/.git"); err != nil {
		return g
	}
	g.IsRepo = true

	// 1. Basic Info
	g.Branch = run(root, "rev-parse", "--abbrev-ref", "HEAD")
	g.Hash = run(root, "rev-parse", "--short", "HEAD")

	// 2. Status Parsing (FIXED)
	statusRaw := run(root, "status", "--porcelain")
	if statusRaw != "" {
		for _, line := range strings.Split(statusRaw, "\n") {
			if len(line) < 3 { continue }
			
			// Porcelain format: "XY PATH" (XY are 2 chars status, then space)
			// –ú—ã –±–µ—Ä–µ–º –ø–µ—Ä–≤—ã–µ 2 —Å–∏–º–≤–æ–ª–∞ –∫–∞–∫ –∫–æ–¥
			code := line[:2]
			// –ê –∏–º—è —Ñ–∞–π–ª–∞ –±–µ—Ä–µ–º, –æ–±—Ä–µ–∑–∞—è –ø–µ—Ä–≤—ã–µ 3 —Å–∏–º–≤–æ–ª–∞ –∏ —É–¥–∞–ª—è—è –ø—Ä–æ–±–µ–ª—ã –ø–æ –∫—Ä–∞—è–º
			// –ï—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ –∫–æ—Ä–æ—á–µ, –∑–∞—â–∏—â–∞–µ–º—Å—è
			var file string
			if len(line) > 3 {
				file = strings.TrimSpace(line[3:])
			} else {
				file = line
			}

			icon := "üìù" // Modified
			if strings.Contains(code, "?") { icon = "‚ú®" } // Untracked
			if strings.Contains(code, "A") { icon = "‚ûï" } // Added
			if strings.Contains(code, "D") { icon = "üóëÔ∏è" } // Deleted
			
			// –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å—Ç—Ä–æ–∫—É –¥–ª—è UI
			g.StatusItems = append(g.StatusItems, fmt.Sprintf("%s %s", icon, file))
		}
	}

	// 3. Graph Visualization
	// –î–æ–±–∞–≤–∏–ª–∏ --topo-order, —á—Ç–æ–±—ã –ª–∏–Ω–∏–∏ —Ä–∏—Å–æ–≤–∞–ª–∏—Å—å –ø–æ–Ω—è—Ç–Ω–µ–µ
	// –§–æ—Ä–º–∞—Ç: Hash - (Refs) Subject (Time)
	cmd := exec.Command("git", "log", "--graph", "--abbrev-commit", "--decorate", "--date=relative", "--format=format:%h -%d %s (%cr)", "--all", "--color=always", "--topo-order", "-n", "15")
	cmd.Dir = root
	out, _ := cmd.Output()
	g.Graph = string(out)

	return g
}

func run(dir string, args ...string) string {
	cmd := exec.Command("git", args...)
	cmd.Dir = dir
	out, _ := cmd.Output()
	return strings.TrimSpace(string(out))
}
```

`internal/modules/infra/infra.go`:

```go
package infra

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

type InfraData struct {
	Tools    []string
	K8sObjs  []string
	TfRes    []string
	CiSystem string
	CiGraph  [][]string
}

func Analyze(root string) InfraData {
	i := InfraData{CiSystem: "None"}

	// 1. Scan Tools
	filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil { return nil }
		if info.IsDir() && (info.Name() == ".git" || info.Name() == "node_modules") { return filepath.SkipDir }

		// Terraform
		if strings.HasSuffix(info.Name(), ".tf") {
			content, _ := os.ReadFile(path)
			re := regexp.MustCompile(`resource "(\w+)" "(\w+)"`)
			matches := re.FindAllStringSubmatch(string(content), -1)
			for _, m := range matches {
				i.TfRes = append(i.TfRes, fmt.Sprintf("%s (%s)", m[1], m[2]))
			}
			addTool(&i, "Terraform üèóÔ∏è")
		}

		// Kubernetes
		if strings.HasSuffix(info.Name(), ".yaml") || strings.HasSuffix(info.Name(), ".yml") {
			file, _ := os.Open(path)
			scanner := bufio.NewScanner(file)
			for scanner.Scan() {
				line := strings.TrimSpace(scanner.Text())
				if strings.HasPrefix(line, "kind:") {
					kind := strings.TrimPrefix(line, "kind: ")
					i.K8sObjs = append(i.K8sObjs, fmt.Sprintf("Kind: %s", kind))
					addTool(&i, "Kubernetes ‚ò∏Ô∏è")
				}
			}
		}
		return nil
	})

	// 2. CI/CD
	ghPath := filepath.Join(root, ".github/workflows")
	if files, err := os.ReadDir(ghPath); err == nil && len(files) > 0 {
		i.CiSystem = "GitHub Actions"
		content, _ := os.ReadFile(filepath.Join(ghPath, files[0].Name()))
		i.CiGraph = buildCiGraph(string(content))
	}

	return i
}

func addTool(i *InfraData, tool string) {
	for _, t := range i.Tools { if t == tool { return } }
	i.Tools = append(i.Tools, tool)
}

func buildCiGraph(yamlContent string) [][]string {
	// –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è –ø–æ–∫–∞–∑–∞ –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º–∞
	// –ï—Å–ª–∏ –º—ã –≤–∏–¥–∏–º –Ω–∞—à–∏ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –∏–∑ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ - —Å—Ç—Ä–æ–∏–º –∫—Ä–∞—Å–∏–≤—ã–π –≥—Ä–∞—Ñ
	if strings.Contains(yamlContent, "lint") && strings.Contains(yamlContent, "unit-test") {
		return [][]string{
			{"lint", "unit-test", "e2e-test"}, // –£—Ä–æ–≤–µ–Ω—å 1 (–ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ)
			{"build"},                          // –£—Ä–æ–≤–µ–Ω—å 2
			{"deploy"},                         // –£—Ä–æ–≤–µ–Ω—å 3
		}
	}
	
	// Fallback
	return [][]string{{"build"}, {"test"}}
}
```

`internal/ui/model.go`:

```go
package ui

import (
	"fmt"
	"strings"

	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/devos-os/d-env/internal/analyzer"
)

// --- Styling ---
var (
	primary   = lipgloss.Color("#6C5CE7") // DevOS Purple
	secondary = lipgloss.Color("#00CEC9") // Cyan
	accent    = lipgloss.Color("#FD79A8") // Pink (–¢–û–¢ –°–ê–ú–´–ô –ê–ö–¶–ï–ù–¢)
	text      = lipgloss.Color("#DFE6E9")
	dark      = lipgloss.Color("#2d3436")
	
	headerStyle = lipgloss.NewStyle().Background(primary).Foreground(text).Bold(true).Padding(0, 1)
	
	// Tabs
	tabStyle    = lipgloss.NewStyle().Padding(0, 2).Foreground(lipgloss.Color("#636e72"))
	activeTab   = lipgloss.NewStyle().Padding(0, 2).Foreground(primary).Bold(true).Underline(true)
	
	// Boxes & Titles
	boxTitle = lipgloss.NewStyle().Foreground(secondary).Bold(true).Underline(true)
	dockerBox = lipgloss.NewStyle().Border(lipgloss.RoundedBorder()).BorderForeground(secondary).Padding(0, 1).Width(50)
	svcBox = lipgloss.NewStyle().Border(lipgloss.RoundedBorder()).Padding(0, 1).MarginRight(1).BorderForeground(accent)
	jobBox = lipgloss.NewStyle().Background(dark).Foreground(text).Padding(0, 2).MarginRight(1).Bold(true)
)

type model struct {
	data      analyzer.Report
	activeTab int
	viewport  viewport.Model
	ready     bool
	quitting  bool
}

func InitialModel(path string) model { return model{data: analyzer.Analyze(path)} }
func (m model) Init() tea.Cmd { return nil }

func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		k := msg.String()
		if k == "q" || k == "ctrl+c" { return m, tea.Quit }
		if k == "tab" || k == "right" { m.activeTab = (m.activeTab + 1) % 4; m.viewport.SetContent(m.render()) }
		if k == "left" || k == "shift+tab" { m.activeTab--; if m.activeTab < 0 { m.activeTab = 3 }; m.viewport.SetContent(m.render()) }
	case tea.WindowSizeMsg:
		if !m.ready {
			m.viewport = viewport.New(msg.Width, msg.Height-6)
			m.viewport.SetContent(m.render())
			m.ready = true
		} else { m.viewport.Width = msg.Width; m.viewport.Height = msg.Height - 6 }
	}
	m.viewport, _ = m.viewport.Update(msg)
	return m, nil
}

func (m model) View() string {
	if !m.ready { return "Scanning project..." }
	
	tabs := []string{"1. MAIN", "2. GIT", "3. DOCKER", "4. INFRA"}
	var row []string
	for i, t := range tabs {
		if i == m.activeTab { row = append(row, activeTab.Render(t)) } else { row = append(row, tabStyle.Render(t)) }
	}
	
	return fmt.Sprintf("%s\n%s\n%s", 
		headerStyle.Render(" DevOS Project MRI 1.5 "), 
		lipgloss.JoinHorizontal(lipgloss.Top, row...),
		m.viewport.View())
}

func (m model) render() string {
	var s strings.Builder
	d := m.data

	switch m.activeTab {
	// --- TAB 1: MAIN ---
	case 0:
		s.WriteString(fmt.Sprintf("\nüìä Project Health: %d/100\n", d.General.HealthScore))
		if len(d.General.Risks) > 0 {
			s.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("#ff7675")).Render("‚ö†Ô∏è  RISKS:") + "\n")
			for _, r := range d.General.Risks { s.WriteString(fmt.Sprintf(" - %s\n", r)) }
		}
		
		s.WriteString("\n" + boxTitle.Render("DETECTED STACK") + "\n")
		for _, st := range d.General.Stacks {
			s.WriteString(fmt.Sprintf(" ‚Ä¢ %s (%s)\n", lipgloss.NewStyle().Foreground(lipgloss.Color(st.Color)).Render(st.Name), st.Version))
		}
		
		s.WriteString("\n" + boxTitle.Render("FILE TREE") + "\n")
		s.WriteString(d.General.Tree)

	// --- TAB 2: GIT ---
	case 1:
		if !d.Git.IsRepo { return "\nNot a git repository." }
		s.WriteString(fmt.Sprintf("\nüåø Branch: %s  |  commit: %s\n", d.Git.Branch, d.Git.Hash))
		
		s.WriteString("\n" + boxTitle.Render("COMMIT HISTORY (Graph)") + "\n")
		s.WriteString(d.Git.Graph) // ASCII graph rendered by git log
		
		s.WriteString("\n" + boxTitle.Render("STATUS") + "\n")
		for _, item := range d.Git.StatusItems { s.WriteString(item + "\n") }

	// --- TAB 3: DOCKER ---
	case 2:
		if !d.Docker.Found { return "\nNo Docker found." }
		
		// Dockerfile
		if d.Docker.Dockerfile.Found {
			s.WriteString("\n" + boxTitle.Render("BUILD PIPELINE") + "\n\n")
			for i, stage := range d.Docker.Dockerfile.Stages {
				header := fmt.Sprintf("üèóÔ∏è  STAGE %d: %s", i+1, stage.Name)
				if stage.IsFinal { header += " (FINAL)" }
				
				content := fmt.Sprintf("Base: %s\n", stage.BaseImage)
				for _, link := range stage.Links {
					content += lipgloss.NewStyle().Foreground(accent).Render(fmt.Sprintf("‚¨Ö From %s", link)) + "\n"
				}
				
				s.WriteString(dockerBox.Render(header + "\n" + content))
				if i < len(d.Docker.Dockerfile.Stages)-1 { s.WriteString("\n      ‚¨á\n") }
			}
		}
		
		// Compose
		if d.Docker.Compose.Found {
			s.WriteString("\n\n" + boxTitle.Render("COMPOSE TOPOLOGY") + "\n\n")
			var boxes []string
			for _, svc := range d.Docker.Compose.Services {
				info := fmt.Sprintf("üì¶ %s\nImage: %s", svc.Name, svc.Image)
				if len(svc.Links) > 0 {
					info += fmt.Sprintf("\n\nNeeds:\n%s", strings.Join(svc.Links, "\n"))
				}
				boxes = append(boxes, svcBox.Render(info))
			}
			s.WriteString(lipgloss.JoinHorizontal(lipgloss.Top, boxes...))
		}

	// --- TAB 4: INFRA ---
	case 3:
		s.WriteString("\n" + boxTitle.Render("INFRASTRUCTURE RESOURCES") + "\n")
		
		if len(d.Infra.K8sObjs) > 0 {
			s.WriteString(lipgloss.NewStyle().Foreground(secondary).Render("Kubernetes:") + "\n")
			for _, k := range d.Infra.K8sObjs { s.WriteString(" ‚ò∏Ô∏è  " + k + "\n") }
		}
		if len(d.Infra.TfRes) > 0 {
			s.WriteString(lipgloss.NewStyle().Foreground(secondary).Render("Terraform:") + "\n")
			for _, t := range d.Infra.TfRes { s.WriteString(" üèóÔ∏è  " + t + "\n") }
		}

		s.WriteString("\n" + boxTitle.Render("CI/CD PIPELINE") + "\n")
		if d.Infra.CiSystem != "" {
			s.WriteString(fmt.Sprintf("System: %s\n\n", d.Infra.CiSystem))
			
			// Render Graph Levels
			for i, level := range d.Infra.CiGraph {
				var jobs []string
				for _, job := range level {
					jobs = append(jobs, jobBox.Render(job))
				}
				// Render parallel jobs horizontally
				s.WriteString(lipgloss.JoinHorizontal(lipgloss.Center, jobs...))
				
				// Arrow down
				if i < len(d.Infra.CiGraph)-1 {
					s.WriteString("\n      ‚¨á (depends on)\n")
				}
			}
		} else {
			s.WriteString("No CI/CD configuration detected.")
		}
	}
	return s.String()
}
```